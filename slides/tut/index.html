<!DOCTYPE html>
<html>
  <head>
    <title>scala cat execise</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
      .image-50 img {
        width: 50%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

```tut:invisible

```

class: center, middle

# scala cat execise
Chenghsien Wen • `@chenghsienwen`


???
- notes here
- see https://remarkjs.com/#1
- see https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet

---
# execise from scala with cats 2 book

[free download](https://www.scalawithcats.com/ "www.scalawithcats.com")

![:scale 90%](resources/scala-with-cats2.jpeg)

---
# Agenda
##  what is category theory?
##  what is type class in scala?
##  cats import structure
##  main type class in cats
---
# what is category theory?
### how things compose and transform
![:scale 60%](resources/category-theory-graph.png)
---
# type class in scala
```tut:silent
trait Printable[A] {
  def format(a: A): String
}

object PrintableInstance {
  implicit val strPrint: Printable[String] = new Printable[String] {
    def format(a: String): String = a
  }
  implicit val intPrint: Printable[Int] = new Printable[Int] {
    def format(a: Int): String = a.toString
  }
}

object Printable {
  def format[A](a: A)(implicit p: Printable[A]): String = p.format(a)
}

object PrintableSyntax {
  implicit class PrintableOps[A](a: A)(implicit p: Printable[A]) {
    def show: String = p.format(a)
  }
}
```
---
#run show
```tut:silent
import com.vpon.cat.Printable
import com.vpon.cat.PrintableSyntax.PrintableOps
import com.vpon.cat.PrintableInstance._
```
```tut:book
Printable.format("xxx")
"aaa".show
```
---
# add one more instance
```tut:silent
import com.vpon.cat.Printable
import com.vpon.cat.PrintableSyntax.PrintableOps
import com.vpon.cat.PrintableInstance._

final case class Cat(name: String, age: Int, color: String)

implicit val catPrint: Printable[Cat] = new Printable[Cat] {
  def format(cat: Cat): String = {
    val name = Printable.format(cat.name)
    val age = Printable.format(cat.age)
    val color = Printable.format(cat.color)
    s"$name is a $age year-old $color cat."
  }
}
```
```tut:book
println(Printable.format("xxx"))
println("aaa".show)
println(Cat("meme", 5, "yellow").show)
```
---
# show type class in cats

```tut:silent
//ref:https://typelevel.org/cats/typeclasses/show.html
import cats.Show
import cats.syntax.show._


case class Person(name: String, age: Int)
implicit val showPerson: Show[Person] = Show.show(person => s"name: ${person.name}, age: ${person.age}")
```
```tut:book
println(Person("John", 31).show)
```
---
#Eq
* issue on **==**
```tut:book
List(1, 2, 3).map(Option(_)).filter(item => item == 1)
```
* use cats eq for **type safe** equality
* === compares two objects for equality;
* =!= compares two objects for inequality.
```tut:silent
import cats.Eq
import cats.instances.all._
import cats.syntax.eq._
```
```tut:fail
List(1, 2, 3).map(Option(_)).filter(item => item === 1)
```
---
#cats import structure
* cats.x for core/"kernel" types;
* cats.data for data types such as **Validated, monad transformers**, etc.;
* cats.syntax.x._ for extension method support, so you can call e.g. sth.asRight, sth.pure, and so on;
* cats.instances.x._ for actual implicit scope import of implementation of the various typeclasses for specific types, so
that when you call e.g. sth.pure you don’t get an "implicit not found" error.
* you can use *import cats.implicits._* to include all instances and syntax
---
#main type class in cats
* Monoid and Semigroup 
* Functor 
* Monad and Moand transforer
* Semigroupal and Applicative 
* Traverse and Foldable
---
###monad type class hierachy
![:scale 75%](resources/monad-type-class-hierachy.jpeg)
---
###definition of monoid: a monoid for a type A is:
* an operation combine with type (A, A) => A
* an element empty of type A
```tut:silent
trait Monoid[A] {
  def combine(x: A, y: A): A
  def empty: A
}
```

### monoids must formally obey several laws. For all values x , y , and z , in A 
* combine must be associative and
* empty must be an identity element:

---
### definition of semigroup: just combine part of monoid
```tut:silent
trait Semigroup[A] {
  def combine(x: A, y: A): A
}
trait Monoid[A] extends Semigroup[A] {
  def empty: A
}
```
---
### monoid execise1
```tut:silent
import cats.Monoid
import cats.instances.all._
import cats.syntax.semigroup._
import cats.syntax.option._

```
```tut:book
val c1 = Set(1, 2) |+| Set(2, 3)

val c2 = Set("A", "B") |+| Set("B", "C")

val c3 = Set(1.some, 2.some) |+| Set(2.some, 3.some)
```
### monoid execise2 on next page
---
```tut:silent
import cats.Monoid
import cats.instances.all._
import cats.syntax.semigroup._
import cats.syntax.option._

case class Order(totalCost: Double, quantity: Double)
implicit val orderMono = new Monoid[Order] {
  def combine(x: Order, y: Order): Order = x.copy(totalCost = x.totalCost |+| y.totalCost, quantity = x.quantity |+| y.quantity)
  def empty: Order = Order(0, 0)
}
def addInt(items: List[Int]): Int = items.foldLeft(Monoid[Int].empty)((a, b) => a |+| b)

def add[A](items: List[A])(implicit monoid: Monoid[A]): A = items.foldLeft(monoid.empty)((a, b) => a |+| b)
```
```tut:book
val list1 = List(Some(1), Some(2), None) 
val list2 = (0 to 5).map(i => Order(i, i)).toList
val result1 = add(list1)
val result2 = add(list2)
```
---
###functor: a functor is anything with a map method
![:scale 90%](resources/map-type-chart.jpeg)
---
* We should think of map not as an iteration pattern, but as a way of sequencing computations on values ignoring some
complication dictated by the relevant data type

```tut:silent
//package cats
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}
```
* F[_]: **type constructors and higher kinded types**
---
#### Functor Laws
* Identity: calling map with the identity function is the same as doing nothing:
```scala
fa.map(a => a) == fa
```
* Composition: mapping with two functions f and g is the same as
mapping with f and then mapping with g :
```scala
fa.map(g(f(_))) == fa.map(f).map(g)
```
* The trick is not to confuse type constructors with generic types. 

* List is a **typeconstructor**, 
List[A] is a **type**:

* There’s a close analogy here with functions and values. Functions are value constructors
```scala
math.abs // function, takes one parameter
math.abs(x) // value, produced by applying a value parameter
```
---
### lift:
* Functor provides a method called lift , which converts a function of 
**type A => B** to one that operates over a functor and has type **F[A] => F[B]** :

```scala
import cats.Functor
import cats.instances.all._
import cats.syntax.functor._
val func = (x: Int) => x + 1
// func: Int => Int = <function1>
val liftedFunc = Functor[Option].lift(func)
// liftedFunc: Option[Int] => Option[Int] = cats.Functor$$Lambda$7972/0x000000084250f840@195657fa58

liftedFunc(Option(1))
// res1: Option[Int] = Some(2)
```
---
### Functors represent sequencing behaviours. 
####We covered three types of functor in this chapter:
* Regular covariant Functors , with their map method, represent the abil‐
ity to apply functions to a value in some context. Successive calls to
map apply these functions in sequence, each accepting the result of its
predecessor as a parameter.
* Contravariant functors, with their contramap method, represent the
ability to “prepend” functions to a function‐like context. Successive
calls to contramap sequence these functions in the opposite order to
map .
* Invariant functors, with their imap method, represent bidirectional
transformations.
---
* contramap
![:scale 90%](resources/contramap-type-chart.jpeg)
* imap: equivalent to a combination of map and contramap
![:scale 90%](resources/imap-type-chart.jpeg)
---
* ex: Play JSON’s Format and scodec’s Codec .

```tut:silent
trait Codec[A] {
  def encode(value: A): String
  def decode(value: String): A
  def imap[B](dec: A => B, enc: B => A): Codec[B] = ???
}
def encode[A](value: A)(implicit c: Codec[A]): String =
  c.encode(value)
def decode[A](value: String)(implicit c: Codec[A]): A =
  c.decode(value)

implicit val stringCodec: Codec[String] = new Codec[String] {
  def encode(value: String): String = value
  def decode(value: String): String = value
}
```
* to extend instances by imap

```tut:reset
import com.vpon.cat.Codec
import com.vpon.cat.CodecInstances._
implicit val intCodec: Codec[Int] = stringCodec.imap(_.toInt, _.toString)
implicit val booleanCodec: Codec[Boolean] = stringCodec.imap(_.toBoolean, _.toString)
```
---
* Contravariant and Invariant in Cats

```tut:silent
trait Contravariant[F[_]] {
  def contramap[A, B](fa: F[A])(f: B => A): F[B]
}
trait Invariant[F[_]] {
  def imap[A, B](fa: F[A])(f: A => B)(g: B => A): F[B]
}
```
```tut:silent
import cats.Contravariant
import cats.Show
import cats.instances.string._

val showString = Show[String]
val showSymbol = Contravariant[Show].

contramap(showString)((sym: Symbol) => s"'${sym.name}")
showSymbol.show(Symbol("dave"))
```
* use syntax:

```scala
import cats.syntax.contravariant._ // for contramap
showString.contramap[Symbol](sym => s"'${sym.name}").show(Symbol("dave"))
// res2: String = "'dave"
```
---
* imap on monoid to extend instance

```scala
import cats.Monoid
import cats.instances.string._ // for Monoid
import cats.syntax.invariant._ // for imap
import cats.syntax.semigroup._ // for |+|

implicit val symbolMonoid: Monoid[Symbol] =
Monoid[String].imap(Symbol.apply)(_.name)
Monoid[Symbol].empty
// res3: Symbol = '
Symbol("a") |+| Symbol("few") |+| Symbol("words")
// res4: Symbol = 'afewwords
```
---
* functor execise1

```tut:silent
import cats.Functor
import cats.instances.all._
import cats.syntax.functor._

// trait Functor[F[_]] {
// def map[A, B](fa: F[A])(f: A => B): F[B]
// }

sealed trait Tree[+A]
final case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]
final case class Leaf[A](value: A) extends Tree[A]

implicit val treeFunctor: Functor[Tree] = new Functor[Tree] {
  def map[A, B](fa: Tree[A])(f: A => B): Tree[B] = {
    fa match {
      case Branch(left, right) => Branch(map(left)(f), map(right)(f))
      case Leaf(value) => Leaf(f(value))
    }
  }
}

object Tree {
  def branch[A](left: Tree[A], right: Tree[A]): Tree[A] =
    Branch(left, right)
  def leaf[A](value: A): Tree[A] =
    Leaf(value)
}
```
```tut:book
Tree.branch(Tree.leaf(10), Tree.leaf(20)).map(_ * 2)
```
---
* partial unification need to add **YpartialUnification**(before scala2.13) in scalaOption

```scala
import cats.Functor
import cats.instances.function._ // for Functor
import cats.syntax.functor._ // for map
val func1 = (x: Int) => x.toDouble
val func2 = (y: Double) => y * 2

val func3 = func1.map(func2)
// func3: Int => Double = scala.Function1$$Lambda$7919/0x00000008424d3040@76a18834
```
* otherwise we’ll get a compiler error:

```scala
func1.map(func2)
// <console>: error: value map is not a member of Int => Double
//func1.map(func2)
```
---
###The partial unification in the Scala compiler works by fixing type parameters
from left to right. In the above example, the compiler fixes the Int in Int =>
Double and looks for a Functor for functions of type Int => ?

```scala
type F[A] = Int => A
val functor = Functor[F]
```
* compiler need to transform Function1 to Functor

```scala
trait Function1[-A, +B] {
  def apply(arg: A): B
}

trait Functor[F[_]] {
  def map[A, B](fa: F[A])(func: A => B): F[B]
}
```
---
#Monad
* a monad is anything with a constructor and a flatMap method
![:scale 90%](resources/flatMap-type-chart.jpeg)

* Monads are all about sequencing and fail fast 
* => how about if we don't want to fail fast and run parraral?(use .par)
---
###Monad operation
* pure , of type A => F[A] ;
* flatMap , of type (F[A], A => F[B]) => F[B] .

```tut:silent
trait Monad[F[_]] {
  def pure[A](value: A): F[A]
  def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]
}
```
### Monad Laws
* Left and right identity

```scala
pure(a).flatMap(func) == func(a)
m.flatMap(pure) == m
```
* Associativity

```scala
m.flatMap(f).flatMap(g) == m.flatMap(x => f(x).flatMap(g))
```
---
* Id monad is a good way for test

```tut:silent
import cats.Monad
import cats.syntax.functor._ // for map
import cats.syntax.flatMap._ // for flatMap
import cats.instances.all._
import cats.Id
def sumSquare[F[_]: Monad](a: F[Int], b: F[Int]): F[Int] =
  for {
    x <- a 
    y <- b 
  } yield x*x + y*y 
```
```tut:book
sumSquare(Option(3), Option(4)) 
sumSquare(List(1, 2, 3),List(4, 5)) 
sumSquare(3:Id[Int], 4:Id[Int]) 
```
```tut:fail
sumSquare(3, 4) 
```
---
* Either is monad after scala 2.12(right biased)

```scala
for {
  a <- either1
  b <- either2
} yield a + b
// res1: Either[String, Int] = Right(42)
```

* in scala 2.11,need to assign .right

```scala
for {
  a <- either1.right
  b <- either2.right
} yield a + b
```
---
* smart constructor for let Right and Left type can be **Either** type

```scala
import cats.syntax.either._ // for asRight
val a = 3.asRight[String]
// a: Either[String, Int] = Right(3)
val b = 4.asRight[String]
// b: Either[String, Int] = Right(4)

for {
  x <- a
  y <- b
} yield x*x + y*y
// res3: Either[String, Int] = Right(25)
```
* This helps avoid type inference problems
---
* issue example

```tut:fail
def countPositive(nums: List[Int]) =
  nums.foldLeft(Right(0)) { (accumulator, num) =>
    if(num > 0) {
      accumulator.map(_ + 1)
    } else {
      Left("Negative. Stopping!")
    }
  }
```
* this compile fail due to
1. the compiler infers the type of the accumulator as **Right** instead of **Either** ;
2. we didn’t specify type parameters for Right.apply so the compiler infers the left parameter as **Nothing** .

---
* how to fix: use asRight to let 0 is Either type

```tut:silent
import cats.syntax.either._ // for asRight

def countPositive(nums: List[Int]) =
  nums.foldLeft(0.asRight[String]) { (accumulator, num) =>
  if(num > 0) {
    accumulator.map(_ + 1)
  } else {
    Left("Negative. Stopping!")
  }
}
```
```tut:book
countPositive(List(1, 2, 3))
countPositive(List(1, -2, 3))
```
---
###transforming either:
* getOrElse, orElse
```scala
import cats.syntax.either._
"Error".asLeft[Int].getOrElse(0)
// res11: Int = 0
"Error".asLeft[Int].orElse(2.asRight[String])
// res12: Either[String, Int] = Right(2)
```
* ensure
```scala
-1.asRight[String].ensure("Must be non-negative!")(_ > 0)
// res13: Either[String, Int] = Left("Must be non-negative!")
```

* recover, recoverWith
```scala
"error".asLeft[Int].recover {
  case _: String => -1
}
// res14: Either[String, Int] = Right(-1)
"error".asLeft[Int].recoverWith {
  case _: String => Right(-1)
}
// res15: Either[String, Int] = Right(-1)
```
---
* leftMap, bimap
```scala
"foo".asLeft[Int].leftMap(_.reverse)
// res16: Either[String, Int] = Left("oof")
6.asRight[String].bimap(_.reverse, _ * 7)
// res17: Either[String, Int] = Right(42)
"bar".asLeft[Int].bimap(_.reverse, _ * 7)
// res18: Either[String, Int] = Left("rab")
```

* swap
```scala
123.asRight[String]
// res19: Either[String, Int] = Right(123)
123.asRight[String].swap
// res20: Either[Int, String] = Left(123)
```
---
* error handling by Either

```tut:silent
object wrapper {
  sealed trait LoginError extends Product with Serializable
  final case class UserNotFound(username: String) extends LoginError
  final case class PasswordIncorrect(username: String) extends LoginError
  case object UnexpectedError extends LoginError
}
import wrapper._
case class User(username: String, password: String)
type LoginResult = Either[LoginError, User]

// Choose error-handling behaviour based on type:
def handleError(error: LoginError): Unit =
  error match {
    case UserNotFound(u) =>
      println(s"User not found: $u")
    case PasswordIncorrect(u) =>
      println(s"Password incorrect: $u")
    case UnexpectedError =>
      println(s"Unexpected error")
  }
```
```tut:book
val result1: LoginResult = User("dave", "passw0rd").asRight
val result2: LoginResult = UserNotFound("dave").asLeft

result1.fold(handleError, println)
result2.fold(handleError, println)
```
---
*  **Error recovery** is important when processing large jobs. We don’t want
to run a job for a day and then find it failed on the last element.
*  **Error reporting** is equally important. We need to know what went
wrong, not just that something went wrong.
*  In a number of cases, we want to collect all the errors, not just the first
one we encountered. A typical example is **validating a web form**. It’s a
far better experience to report all errors to the user when they submit
a form than to report them one at a time.
---
###MonadError
```tut:silent
//package cats
trait MonadError[F[_], E] extends Monad[F] {
  // Lift an error into the `F` context:
  def raiseError[A](e: E): F[A]
  // Handle an error, potentially recovering from it:
  def handleErrorWith[A](fa: F[A])(f: E => F[A]): F[A]
  // Handle all errors, recovering from them:
  def handleError[A](fa: F[A])(f: E => A): F[A]
  // Test an instance of `F`,
  // failing if the predicate is not satisfied:
  def ensure[A](fa: F[A])(e: E)(f: A => Boolean): F[A]
}
```
---
* handleErrorWith via *cats.syntax.applicativError*
* ensure via *cats.syntax.monadError*

```scala
import cats.syntax.applicative._ // for pure
import cats.syntax.applicativeError._ // for raiseError etc
import cats.syntax.monadError._ // for ensure
// Alias Either to a type constructor with one parameter:
type ErrorOr[A] = Either[String, A]

val success = 42.pure[ErrorOr]
// success: ErrorOr[Int] = Right(42)
val failure = "Badness".raiseError[ErrorOr, Int]
// failure: ErrorOr[Int] = Left("Badness")
failure.handleErrorWith{
    case "Badness" => 256.pure[ErrorOr]
    case _ => ("It's not ok").raiseError[ErrorOr, Int]
}
// res4: ErrorOr[Int] = Right(256)
success.ensure("Number to low!")(_ > 1000)
// res5: ErrorOr[Int] = Left("Number to low!")
```
---
* monad execise1

```tut:silent
import cats.MonadError
import cats.syntax.monadError._
import cats.syntax.applicativeError._
import cats.instances.all._
import scala.util.{Try, Success, Failure}

def validateAdult[F[_]](age: Int)(implicit me: MonadError[F, Throwable]): F[Int] = {
  age >= 18 match{
    case true => me.pure(age)
    case false => me.raiseError(throw new java.lang.IllegalArgumentException("Age must be greater than or equal to 18"))
  }
}
```
```tut:book
validateAdult[Try](18)
type ExceptionOr[A] = Either[Throwable, A]
```
```tut:fail
validateAdult[ExceptionOr](-1)
```
---
###Eval monad
#### eval monad with 3 types
* now: call‐by‐value which is eager and memoized;
* always: call‐by‐name which is lazy and not memoized; and
* later: call‐by‐need which is lazy and memoized.

```tut:book
import cats.Eval
val now = Eval.now(math.random + 1000)

val always = Eval.always(math.random + 3000)

val later = Eval.later(math.random + 2000)

now.value

always.value

later.value
```
---
* mapping functions are always called lazily on demand ( **def semantics**):

```tut:book
import cats.Eval
val ans = for {
  a <- Eval.now{ println("Calculating A"); 40 }
  b <- Eval.always{ println("Calculating B"); 2 }
} yield {
  println("Adding A and B")
  a + b
}

ans.value // first access

ans.value // second access
```
---
* memorized method

```tut:book
import cats.Eval
val saying = Eval.always{ println("Step 1"); "The cat" 
  }.map{ str => println("Step 2"); s"$str sat on" 
  }.memoize.map{ str => println("Step 3"); s"$str the mat" 
}

saying.value // first access

saying.value // second access
```

---
###stack safety of evals map and flatMap
* issue example: this would cause stack overflow

```scala
def factorial(n: BigInt): BigInt =
  if(n == 1) n else n * factorial(n - 1)
factorial(50000)
// java.lang.StackOverflowError
```
* use eavl to refactor….still stack overflow

```scala
def factorial(n: BigInt): Eval[BigInt] =
  if(n == 1) {
    Eval.now(n)
  } else {
    factorial(n - 1).map(_ * n)
  }
factorial(50000).value
// java.lang.StackOverflowError
```
---
* stack overflow reason
* still making all the recursive calls to factorial before we start working with Eval's map method.
* solution: use **eavl.defer** for the rescue!!

```tut:book
import cats.Eval
def factorial(n: BigInt): Eval[BigInt] =
  if(n == 1) {
    Eval.now(n)
  } else {
    Eval.defer(factorial(n - 1).map(_ * n))
  }
factorial(50000).value
```
* cost of eavl: It avoids consuming stack by creating a chain of function objects on the heap. There are still limits on
how deeply we can nest computations, but they are bounded by the **size of the heap rather than the stack**.
---
###Reference
* [scala with cats2](https://www.scalawithcats.com/ "www.scalawithcats.com")
* [cats FAQ](https://typelevel.org/cats/faq.html)
* [Useful Ammonite snippets](https://gist.github.com/MateuszKubuszok/a80503b28f289f08f2f6c6c70871e8d3#partial-unification)
* [9-tips-about-using-cats-in-scala-you-might-want-to-know](https://blog.softwaremill.com/9-tips-about-using-cats-in-scala-you-might-want-to-know-e1bafd365f88)
* [monad-transformers-for-the-working-programmer](https://blog.buildo.io/monad-transformers-for-the-working-programmer-aa7e981190e7)
* [flinters engineers blog](https://labs.septeni.co.jp/entry/functional-brothers)
* [Monad Transformers for the working programmer | by Gabriele Petronella](https://speakerdeck.com/danielasfregola/scalamatsuri-2018-a-pragmatic-introduction-to-category-theory)
* [DanielaSfregola github](https://github.com/DanielaSfregola)

---
class: center, middle

# Thanks!
Code and slides at `chenghsienwen/scalacatexecise` on GitHub

## Questions?





 </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
       remark.macros.scale = function (percentage) {
          var url = this;
          return '<img src="' + url + '" style="width: ' + percentage + '" />';
        };
        var slideshow = remark.create();
    </script>
  </body>
</html>
