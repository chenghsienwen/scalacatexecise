<!DOCTYPE html>
<html>
  <head>
    <title>scala cat execise</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
      .image-50 img {
        width: 50%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">




class: center, middle

# scala cat execise
Chenghsien Wen • `@chenghsienwen`


???
- notes here
- see https://remarkjs.com/#1
- see https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet

---
# execise from scala with cats 2 book

[free download](https://www.scalawithcats.com/ "www.scalawithcats.com")

![:scale 90%](resources/scala-with-cats2.jpeg)

---
# Agenda
##  what is category theory?
##  what is type class in scala?
##  cats import structure
##  main type class in cats
---
# what is category theory?
### how things compose and transform
![:scale 60%](resources/category-theory-graph.png)
---
# type class in scala
```scala
trait Printable[A] {
  def format(a: A): String
}

object PrintableInstance {
  implicit val strPrint: Printable[String] = new Printable[String] {
    def format(a: String): String = a
  }
  implicit val intPrint: Printable[Int] = new Printable[Int] {
    def format(a: Int): String = a.toString
  }
}

object Printable {
  def format[A](a: A)(implicit p: Printable[A]): String = p.format(a)
}

object PrintableSyntax {
  implicit class PrintableOps[A](a: A)(implicit p: Printable[A]) {
    def show: String = p.format(a)
  }
}
```
---
#run show
```scala
import com.vpon.cat.Printable
import com.vpon.cat.PrintableSyntax.PrintableOps
import com.vpon.cat.PrintableInstance._
```
```scala
Printable.format("xxx")
// res0: String = xxx

"aaa".show
// res1: String = aaa
```
---
# add one more instance
```scala
import com.vpon.cat.Printable
import com.vpon.cat.PrintableSyntax.PrintableOps
import com.vpon.cat.PrintableInstance._

final case class Cat(name: String, age: Int, color: String)

implicit val catPrint: Printable[Cat] = new Printable[Cat] {
  def format(cat: Cat): String = {
    val name = Printable.format(cat.name)
    val age = Printable.format(cat.age)
    val color = Printable.format(cat.color)
    s"$name is a $age year-old $color cat."
  }
}
```
```scala
println(Printable.format("xxx"))
// xxx

println("aaa".show)
// aaa

println(Cat("meme", 5, "yellow").show)
// meme is a 5 year-old yellow cat.
```
---
# show type class in cats

```scala
//ref:https://typelevel.org/cats/typeclasses/show.html
import cats.Show
import cats.syntax.show._


case class Person(name: String, age: Int)
implicit val showPerson: Show[Person] = Show.show(person => s"name: ${person.name}, age: ${person.age}")
```
```scala
println(Person("John", 31).show)
// name: John, age: 31
```
---
#Eq
* issue on Eq
```scala
List(1, 2, 3).map(Option(_)).filter(item => item == 1)
// <console>:29: warning: Option[Int] and Int are unrelated: they will most likely never compare equal
//        List(1, 2, 3).map(Option(_)).filter(item => item == 1)
//                                                         ^
// res7: List[Option[Int]] = List()
```
* use cats eq for **type safe** equality
* === compares two objects for equality;
* =!= compares two objects for inequality.
```scala
import cats.Eq
import cats.instances.all._
import cats.syntax.eq._
```
```scala
scala> List(1, 2, 3).map(Option(_)).filter(item => item === 1)
<console>:36: error: type mismatch;
 found   : Int(1)
 required: Option[Int]
       List(1, 2, 3).map(Option(_)).filter(item => item === 1)
                                                            ^
```
---
#cats import structure
* cats.x for core/"kernel" types;
* cats.data for data types such as **Validated, monad transformers**, etc.;
* cats.syntax.x._ for extension method support, so you can call e.g. sth.asRight, sth.pure, and so on;
* cats.instances.x._ for actual implicit scope import of implementation of the various typeclasses for specific types, so
that when you call e.g. sth.pure you don’t get an "implicit not found" error.

---
#main type class in cats
* Monoid and Semigroup 
* Functor 
* Monad and Moand transforer
* Semigroupal and Applicative 
* Traverse and Foldable
---
###monad type class hierachy
![:scale 75%](resources/monad-type-class-hierachy.jpeg)
---
###definition of monoid: a monoid for a type A is:
* an operation combine with type (A, A) => A
* an element empty of type A
```scala
trait Monoid[A] {
  def combine(x: A, y: A): A
  def empty: A
}
```

### monoids must formally obey several laws. For all values x , y , and z , in A 
* combine must be associative and
* empty must be an identity element:

---
### definition of semigroup: just combine part of monoid
```scala
trait Semigroup[A] {
  def combine(x: A, y: A): A
}
trait Monoid[A] extends Semigroup[A] {
  def empty: A
}
```
---
### monoid execise1
```scala
import cats.Monoid
import cats.instances.all._
import cats.syntax.semigroup._
import cats.syntax.option._

```
```scala
val c1 = Set(1, 2) |+| Set(2, 3)
// c1: scala.collection.immutable.Set[Int] = Set(1, 2, 3)

val c2 = Set("A", "B") |+| Set("B", "C")
// c2: scala.collection.immutable.Set[String] = Set(A, B, C)

val c3 = Set(1.some, 2.some) |+| Set(2.some, 3.some)
// c3: scala.collection.immutable.Set[Option[Int]] = Set(Some(1), Some(2), Some(3))
```
### monoid execise2 on next page
---
```scala
import cats.Monoid
import cats.instances.all._
import cats.syntax.semigroup._
import cats.syntax.option._

case class Order(totalCost: Double, quantity: Double)
implicit val orderMono = new Monoid[Order] {
  def combine(x: Order, y: Order): Order = x.copy(totalCost = x.totalCost |+| y.totalCost, quantity = x.quantity |+| y.quantity)
  def empty: Order = Order(0, 0)
}
def addInt(items: List[Int]): Int = items.foldLeft(Monoid[Int].empty)((a, b) => a |+| b)

def add[A](items: List[A])(implicit monoid: Monoid[A]): A = items.foldLeft(monoid.empty)((a, b) => a |+| b)
```
```scala
val list1 = List(Some(1), Some(2), None) 
// list1: List[Option[Int]] = List(Some(1), Some(2), None)

val list2 = (0 to 5).map(i => Order(i, i)).toList
// <console>:58: warning: implicit numeric widening
//        val list2 = (0 to 5).map(i => Order(i, i)).toList
//                                            ^
// <console>:58: warning: implicit numeric widening
//        val list2 = (0 to 5).map(i => Order(i, i)).toList
//                                               ^
// list2: List[Order] = List(Order(0.0,0.0), Order(1.0,1.0), Order(2.0,2.0), Order(3.0,3.0), Order(4.0,4.0), Order(5.0,5.0))

val result1 = add(list1)
// result1: Option[Int] = Some(3)

val result2 = add(list2)
// result2: Order = Order(15.0,15.0)
```
---
class: center, middle

# Thanks!
Code and slides at `chenghsienwen/scalacatexecise` on GitHub

## Questions?





 </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
       remark.macros.scale = function (percentage) {
          var url = this;
          return '<img src="' + url + '" style="width: ' + percentage + '" />';
        };
        var slideshow = remark.create();
    </script>
  </body>
</html>
