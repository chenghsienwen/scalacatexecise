<!DOCTYPE html>
<html>
  <head>
    <title>scala cat execise</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
      .image-50 img {
        width: 50%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">




class: center, middle

# scala cat execise
Chenghsien Wen • `@chenghsienwen`
2021/06/17


???
- notes here
- see https://remarkjs.com/#1
- see https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet
---
# About cat
[github link](https://github.com/typelevel/cats "https://github.com/typelevel/cats")

![:scale 100%](resources/cat-git.jpeg)
---
# execise from scala with cats 2 book

[free download](https://www.scalawithcats.com/ "www.scalawithcats.com")

![:scale 90%](resources/scala-with-cats2.jpeg)

---
# Agenda
##  what is category theory?
##  what is type class in scala?
##  cats import structure
##  main type class in cats
---
# what is category theory?
### how things compose and transform
![:scale 60%](resources/category-theory-graph.png)
---
# type class in scala
```scala
trait Printable[A] {
  def format(a: A): String
}

object PrintableInstance {
  implicit val strPrint: Printable[String] = new Printable[String] {
    def format(a: String): String = a
  }
  implicit val intPrint: Printable[Int] = new Printable[Int] {
    def format(a: Int): String = a.toString
  }
}

object Printable {
  def format[A](a: A)(implicit p: Printable[A]): String = p.format(a)
}

object PrintableSyntax {
  implicit class PrintableOps[A](a: A)(implicit p: Printable[A]) {
    def show: String = p.format(a)
  }
}
```
---
#run show
```scala
import com.vpon.cat.Printable
import com.vpon.cat.PrintableSyntax.PrintableOps
import com.vpon.cat.PrintableInstance._
```
```scala
Printable.format("xxx")
// res0: String = xxx

"aaa".show
// res1: String = aaa
```
---
# add one more instance
```scala
import com.vpon.cat.Printable
import com.vpon.cat.PrintableSyntax.PrintableOps
import com.vpon.cat.PrintableInstance._

final case class Cat(name: String, age: Int, color: String)

implicit val catPrint: Printable[Cat] = new Printable[Cat] {
  def format(cat: Cat): String = {
    val name = Printable.format(cat.name)
    val age = Printable.format(cat.age)
    val color = Printable.format(cat.color)
    s"$name is a $age year-old $color cat."
  }
}
```
```scala
println(Printable.format("xxx"))
// xxx

println("aaa".show)
// aaa

println(Cat("meme", 5, "yellow").show)
// meme is a 5 year-old yellow cat.
```
---
# show type class in cats

```scala
//ref:https://typelevel.org/cats/typeclasses/show.html
import cats.Show
import cats.syntax.show._


case class Person(name: String, age: Int)
implicit val showPerson: Show[Person] = Show.show(person => s"name: ${person.name}, age: ${person.age}")
```
```scala
println(Person("John", 31).show)
// name: John, age: 31
```
---
# how about type class in java?

```java
interface Show<A> {
  String show(A a);

  static Show<Integer> showInt() {
    return i -> "int: " + i;
  }
}
final class Functions {
  static <A> String show(A a, Show<A> sh) {
      return sh.show(a);
  }
}
System.out.println(show(12, showInt()));
```
---
#java type class with more type

```java
class Pair<A, B> {
  private A first;
  private B second;

  public Pair(A first, B second) {
    this.first = first;
    this.second = second;
  }

  public A getFirst() {
      return first;
  }

  public B getSecond() {
      return second;
    }
}
```
---
#java type class with more type(cont.)
```java
interface Show<A> {
  String show(A a);

  static Show<Integer> showInt() {
    return i -> "int: " + i;
  }
  static Show<String> showString() {
    return i -> "str: " + i;
  }

  static <A, B> Show<Pair<A, B>> showPair(Show<A> A, Show<B> B) {
    return p -> "{" + A.show(p.getFirst()) + ", " + B.show(p.getSecond()) + "}";
  }
}

final class Functions {
  static <A> String show(A a, Show<A> sh) {
    return sh.show(a);
  }
}
var pair = new Pair<>(1, "hello");
System.out.println(show(pair, showPair(showInt(), showString())));

```
* [more examples](https://github.com/zarinfam/java-type-classes-sample)
---
#Eq
* issue on **==**
```scala
List(1, 2, 3).map(Option(_)).filter(item => item == 1)
// <console>:29: warning: Option[Int] and Int are unrelated: they will most likely never compare equal
//        List(1, 2, 3).map(Option(_)).filter(item => item == 1)
//                                                         ^
// res7: List[Option[Int]] = List()
```
* use cats eq for **type safe** equality
* === compares two objects for equality;
* =!= compares two objects for inequality.
```scala
import cats.Eq
import cats.instances.all._
import cats.syntax.eq._
```
```scala
scala> List(1, 2, 3).map(Option(_)).filter(item => item === 1)
<console>:36: error: type mismatch;
 found   : Int(1)
 required: Option[Int]
       List(1, 2, 3).map(Option(_)).filter(item => item === 1)
                                                            ^
```
---
#cats import structure
* cats.x for core/"kernel" types;
* cats.data for data types such as **Validated, monad transformers**, etc.;
* cats.syntax.x._ for extension method support, so you can call e.g. sth.asRight, sth.pure, and so on;
* cats.instances.x._ for actual implicit scope import of implementation of the various typeclasses for specific types, so
that when you call e.g. sth.pure you don’t get an "implicit not found" error.
* you can use *import cats.implicits._* to include all instances and syntax
---
#main type class in cats
* Monoid and Semigroup 
* Functor 
* Monad and Moand transforer
* Semigroupal and Applicative 
* Traverse and Foldable
---
###monad type class hierachy
![:scale 75%](resources/monad-type-class-hierachy.jpeg)
---
###definition of monoid: a monoid for a type A is:
* an operation combine with type (A, A) => A
* an element empty of type A
```scala
trait Monoid[A] {
  def combine(x: A, y: A): A
  def empty: A
}
```

### monoids must formally obey several laws. For all values x , y , and z , in A 
* combine must be associative and
* empty must be an identity element:

---
### definition of semigroup: just combine part of monoid
```scala
trait Semigroup[A] {
  def combine(x: A, y: A): A
}
trait Monoid[A] extends Semigroup[A] {
  def empty: A
}
```
---
### monoid execise1
```scala
import cats.Monoid
import cats.instances.all._
import cats.syntax.semigroup._
import cats.syntax.option._

```
```scala
val c1 = Set(1, 2) |+| Set(2, 3)
// c1: scala.collection.immutable.Set[Int] = Set(1, 2, 3)

val c2 = Set("A", "B") |+| Set("B", "C")
// c2: scala.collection.immutable.Set[String] = Set(A, B, C)

val c3 = Set(1.some, 2.some) |+| Set(2.some, 3.some)
// c3: scala.collection.immutable.Set[Option[Int]] = Set(Some(1), Some(2), Some(3))
```
### monoid execise2 on next page
---
```scala
import cats.Monoid
import cats.instances.all._
import cats.syntax.semigroup._
import cats.syntax.option._

case class Order(totalCost: Double, quantity: Double)
implicit val orderMono = new Monoid[Order] {
  def combine(x: Order, y: Order): Order = x.copy(totalCost = x.totalCost |+| y.totalCost, quantity = x.quantity |+| y.quantity)
  def empty: Order = Order(0, 0)
}
def addInt(items: List[Int]): Int = items.foldLeft(Monoid[Int].empty)((a, b) => a |+| b)

def add[A](items: List[A])(implicit monoid: Monoid[A]): A = items.foldLeft(monoid.empty)((a, b) => a |+| b)
```
```scala
val list1 = List(Some(1), Some(2), None) 
// list1: List[Option[Int]] = List(Some(1), Some(2), None)

val list2 = (0 to 5).map(i => Order(i, i)).toList
// <console>:58: warning: implicit numeric widening
//        val list2 = (0 to 5).map(i => Order(i, i)).toList
//                                            ^
// <console>:58: warning: implicit numeric widening
//        val list2 = (0 to 5).map(i => Order(i, i)).toList
//                                               ^
// list2: List[Order] = List(Order(0.0,0.0), Order(1.0,1.0), Order(2.0,2.0), Order(3.0,3.0), Order(4.0,4.0), Order(5.0,5.0))

val result1 = add(list1)
// result1: Option[Int] = Some(3)

val result2 = add(list2)
// result2: Order = Order(15.0,15.0)
```
---
###functor: a functor is anything with a map method
![:scale 90%](resources/map-type-chart.jpeg)
---
* We should think of map not as an iteration pattern, but as a way of sequencing computations on values ignoring some
complication dictated by the relevant data type

```scala
//package cats
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}
```
* F[_]: **type constructors and higher kinded types**
---
#### Functor Laws
* Identity: calling map with the identity function is the same as doing nothing:
```scala
fa.map(a => a) == fa
```
* Composition: mapping with two functions f and g is the same as
mapping with f and then mapping with g :
```scala
fa.map(g(f(_))) == fa.map(f).map(g)
```
* The trick is not to confuse type constructors with generic types. 

* List is a **type constructor**, 
List[A] is a **type**:

* There’s a close analogy here with functions and values. Functions are value constructors
```scala
math.abs // function, takes one parameter
math.abs(x) // value, produced by applying a value parameter
```
---
### lift:
* Functor provides a method called lift , which converts a function of 
**type A => B** to one that operates over a functor and has type **F[A] => F[B]** :

```scala
import cats.Functor
import cats.instances.all._
import cats.syntax.functor._
val func = (x: Int) => x + 1
// func: Int => Int = <function1>
val liftedFunc = Functor[Option].lift(func)
// liftedFunc: Option[Int] => Option[Int] = cats.Functor$$Lambda$7972/0x000000084250f840@195657fa58

liftedFunc(Option(1))
// res1: Option[Int] = Some(2)
```
---
### Functors represent sequencing behaviours. 
####We covered three types of functor in this chapter:
* Regular covariant Functors , with their map method, represent the abil‐
ity to apply functions to a value in some context. Successive calls to
map apply these functions in sequence, each accepting the result of its
predecessor as a parameter.
* Contravariant functors, with their contramap method, represent the
ability to “prepend” functions to a function‐like context. Successive
calls to contramap sequence these functions in the opposite order to
map .
* Invariant functors, with their imap method, represent bidirectional
transformations.
---
* contramap
![:scale 90%](resources/contramap-type-chart.jpeg)
* imap: equivalent to a combination of map and contramap
![:scale 90%](resources/imap-type-chart.jpeg)
---
* ex: Play JSON’s Format and scodec’s Codec .

```scala
trait Codec[A] {
  def encode(value: A): String
  def decode(value: String): A
  def imap[B](dec: A => B, enc: B => A): Codec[B] = ???
}
def encode[A](value: A)(implicit c: Codec[A]): String =
  c.encode(value)
def decode[A](value: String)(implicit c: Codec[A]): A =
  c.decode(value)

implicit val stringCodec: Codec[String] = new Codec[String] {
  def encode(value: String): String = value
  def decode(value: String): String = value
}
```
* to extend instances by imap

```scala
scala> import com.vpon.cat.Codec
import com.vpon.cat.Codec

scala> import com.vpon.cat.CodecInstances._
import com.vpon.cat.CodecInstances._

scala> implicit val intCodec: Codec[Int] = stringCodec.imap(_.toInt, _.toString)
intCodec: com.vpon.cat.Codec[Int] = com.vpon.cat.Codec$$anon$1@264391d8

scala> implicit val booleanCodec: Codec[Boolean] = stringCodec.imap(_.toBoolean, _.toString)
booleanCodec: com.vpon.cat.Codec[Boolean] = com.vpon.cat.Codec$$anon$1@4cd45d94
```
---
* Contravariant and Invariant in Cats

```scala
trait Contravariant[F[_]] {
  def contramap[A, B](fa: F[A])(f: B => A): F[B]
}
trait Invariant[F[_]] {
  def imap[A, B](fa: F[A])(f: A => B)(g: B => A): F[B]
}
```
```scala
import cats.Contravariant
import cats.Show
import cats.instances.string._

val showString = Show[String]
val showSymbol = Contravariant[Show].

contramap(showString)((sym: Symbol) => s"'${sym.name}")
showSymbol.show(Symbol("dave"))
```
* use syntax:

```scala
import cats.syntax.contravariant._ // for contramap
showString.contramap[Symbol](sym => s"'${sym.name}").show(Symbol("dave"))
// res2: String = "'dave"
```
---
* imap on monoid to extend instance

```scala
import cats.Monoid
import cats.instances.string._ // for Monoid
import cats.syntax.invariant._ // for imap
import cats.syntax.semigroup._ // for |+|

implicit val symbolMonoid: Monoid[Symbol] =
Monoid[String].imap(Symbol.apply)(_.name)
Monoid[Symbol].empty
// res3: Symbol = '
Symbol("a") |+| Symbol("few") |+| Symbol("words")
// res4: Symbol = 'afewwords
```
---
* functor execise1

```scala
import cats.Functor
import cats.instances.all._
import cats.syntax.functor._

// trait Functor[F[_]] {
// def map[A, B](fa: F[A])(f: A => B): F[B]
// }

sealed trait Tree[+A]
final case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]
final case class Leaf[A](value: A) extends Tree[A]

implicit val treeFunctor: Functor[Tree] = new Functor[Tree] {
  def map[A, B](fa: Tree[A])(f: A => B): Tree[B] = {
    fa match {
      case Branch(left, right) => Branch(map(left)(f), map(right)(f))
      case Leaf(value) => Leaf(f(value))
    }
  }
}

object Tree {
  def branch[A](left: Tree[A], right: Tree[A]): Tree[A] =
    Branch(left, right)
  def leaf[A](value: A): Tree[A] =
    Leaf(value)
}
```
```scala
Tree.branch(Tree.leaf(10), Tree.leaf(20)).map(_ * 2)
// res5: Tree[Int] = Branch(Leaf(20),Leaf(40))
```
---
* partial unification need to add **YpartialUnification**(before scala2.13) in scalaOption

```scala
import cats.Functor
import cats.instances.function._ // for Functor
import cats.syntax.functor._ // for map
val func1 = (x: Int) => x.toDouble
val func2 = (y: Double) => y * 2

val func3 = func1.map(func2)
// func3: Int => Double = scala.Function1$$Lambda$7919/0x00000008424d3040@76a18834
```
* otherwise we’ll get a compiler error:

```scala
func1.map(func2)
// <console>: error: value map is not a member of Int => Double
//func1.map(func2)
```
---
###The partial unification in the Scala compiler works by fixing type parameters
from left to right. In the above example, the compiler fixes the Int in Int =>
Double and looks for a Functor for functions of type Int => ?

```scala
type F[A] = Int => A
val functor = Functor[F]
```
* compiler need to transform Function1 to Functor

```scala
trait Function1[-A, +B] {
  def apply(arg: A): B
}

trait Functor[F[_]] {
  def map[A, B](fa: F[A])(func: A => B): F[B]
}
```
---
#Monad
* a monad is anything with a constructor and a flatMap method
![:scale 90%](resources/flatMap-type-chart.jpeg)

* Monads are all about sequencing and fail fast 
* => how about if we don't want to fail fast and run parraral?(use .par)
---
###Monad operation
* pure , of type A => F[A] ;
* flatMap , of type (F[A], A => F[B]) => F[B] .

```scala
trait Monad[F[_]] {
  def pure[A](value: A): F[A]
  def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]
}
```
### Monad Laws
* Left and right identity

```scala
pure(a).flatMap(func) == func(a)
m.flatMap(pure) == m
```
* Associativity

```scala
m.flatMap(f).flatMap(g) == m.flatMap(x => f(x).flatMap(g))
```
---
* Id monad is a good way for test

```scala
import cats.Monad
import cats.syntax.functor._ // for map
import cats.syntax.flatMap._ // for flatMap
import cats.instances.all._
import cats.Id
def sumSquare[F[_]: Monad](a: F[Int], b: F[Int]): F[Int] =
  for {
    x <- a 
    y <- b 
  } yield x*x + y*y 
```
```scala
sumSquare(Option(3), Option(4)) 
// res6: Option[Int] = Some(25)

sumSquare(List(1, 2, 3),List(4, 5)) 
// res7: List[Int] = List(17, 26, 20, 29, 25, 34)

sumSquare(3:Id[Int], 4:Id[Int]) 
// res8: cats.Id[Int] = 25
```
```scala
scala> sumSquare(3, 4) 
<console>:44: error: no type parameters for method sumSquare: (a: F[Int], b: F[Int])(implicit evidence$1: cats.Monad[F])F[Int] exist so that it can be applied to arguments (Int, Int)
 --- because ---
argument expression's type is not compatible with formal parameter type;
 found   : Int
 required: ?F[Int]
       sumSquare(3, 4)
       ^
<console>:44: error: type mismatch;
 found   : Int(3)
 required: F[Int]
       sumSquare(3, 4)
                 ^
<console>:44: error: type mismatch;
 found   : Int(4)
 required: F[Int]
       sumSquare(3, 4)
                    ^
```
---
* Either is monad after scala 2.12(right biased)

```scala
for {
  a <- either1
  b <- either2
} yield a + b
// res1: Either[String, Int] = Right(42)
```

* in scala 2.11,need to assign .right

```scala
for {
  a <- either1.right
  b <- either2.right
} yield a + b
```
---
* smart constructor for let Right and Left type can be **Either** type

```scala
import cats.syntax.either._ // for asRight
val a = 3.asRight[String]
// a: Either[String, Int] = Right(3)
val b = 4.asRight[String]
// b: Either[String, Int] = Right(4)

for {
  x <- a
  y <- b
} yield x*x + y*y
// res3: Either[String, Int] = Right(25)
```
* This helps avoid type inference problems
---
* issue example

```scala
scala> def countPositive(nums: List[Int]) =
     |   nums.foldLeft(Right(0)) { (accumulator, num) =>
     |     if(num > 0) {
     |       accumulator.map(_ + 1)
     |     } else {
     |       Left("Negative. Stopping!")
     |     }
     |   }
<console>:45: error: type mismatch;
 found   : scala.util.Either[Nothing,Int]
 required: scala.util.Right[Nothing,Int]
             accumulator.map(_ + 1)
                            ^
<console>:47: error: type mismatch;
 found   : scala.util.Left[String,Nothing]
 required: scala.util.Right[Nothing,Int]
             Left("Negative. Stopping!")
                 ^
```
* this compile fail due to
1. the compiler infers the type of the accumulator as **Right** instead of **Either** ;
2. we didn’t specify type parameters for Right.apply so the compiler infers the left parameter as **Nothing** .

---
* how to fix: use asRight to let 0 is Either type

```scala
import cats.syntax.either._ // for asRight

def countPositive(nums: List[Int]) =
  nums.foldLeft(0.asRight[String]) { (accumulator, num) =>
  if(num > 0) {
    accumulator.map(_ + 1)
  } else {
    Left("Negative. Stopping!")
  }
}
```
```scala
countPositive(List(1, 2, 3))
// res10: Either[String,Int] = Right(3)

countPositive(List(1, -2, 3))
// res11: Either[String,Int] = Left(Negative. Stopping!)
```
---
###transforming either:
* getOrElse, orElse
```scala
import cats.syntax.either._
"Error".asLeft[Int].getOrElse(0)
// res11: Int = 0
"Error".asLeft[Int].orElse(2.asRight[String])
// res12: Either[String, Int] = Right(2)
```
* ensure
```scala
-1.asRight[String].ensure("Must be non-negative!")(_ > 0)
// res13: Either[String, Int] = Left("Must be non-negative!")
```

* recover, recoverWith
```scala
"error".asLeft[Int].recover {
  case _: String => -1
}
// res14: Either[String, Int] = Right(-1)
"error".asLeft[Int].recoverWith {
  case _: String => Right(-1)
}
// res15: Either[String, Int] = Right(-1)
```
---
* leftMap, bimap
```scala
"foo".asLeft[Int].leftMap(_.reverse)
// res16: Either[String, Int] = Left("oof")
6.asRight[String].bimap(_.reverse, _ * 7)
// res17: Either[String, Int] = Right(42)
"bar".asLeft[Int].bimap(_.reverse, _ * 7)
// res18: Either[String, Int] = Left("rab")
```

* swap
```scala
123.asRight[String]
// res19: Either[String, Int] = Right(123)
123.asRight[String].swap
// res20: Either[Int, String] = Left(123)
```
---
* error handling by Either

```scala
object wrapper {
  sealed trait LoginError extends Product with Serializable
  final case class UserNotFound(username: String) extends LoginError
  final case class PasswordIncorrect(username: String) extends LoginError
  case object UnexpectedError extends LoginError
}
import wrapper._
case class User(username: String, password: String)
type LoginResult = Either[LoginError, User]

// Choose error-handling behaviour based on type:
def handleError(error: LoginError): Unit =
  error match {
    case UserNotFound(u) =>
      println(s"User not found: $u")
    case PasswordIncorrect(u) =>
      println(s"Password incorrect: $u")
    case UnexpectedError =>
      println(s"Unexpected error")
  }
```
```scala
val result1: LoginResult = User("dave", "passw0rd").asRight
// result1: LoginResult = Right(User(dave,passw0rd))

val result2: LoginResult = UserNotFound("dave").asLeft
// result2: LoginResult = Left(UserNotFound(dave))

result1.fold(handleError, println)
// User(dave,passw0rd)

result2.fold(handleError, println)
// User not found: dave
```
---
*  **Error recovery** is important when processing large jobs. We don’t want
to run a job for a day and then find it failed on the last element.
*  **Error reporting** is equally important. We need to know what went
wrong, not just that something went wrong.
*  In a number of cases, we want to collect all the errors, not just the first
one we encountered. A typical example is **validating a web form**. It’s a
far better experience to report all errors to the user when they submit
a form than to report them one at a time.
---
###MonadError
```scala
//package cats
trait MonadError[F[_], E] extends Monad[F] {
  // Lift an error into the `F` context:
  def raiseError[A](e: E): F[A]
  // Handle an error, potentially recovering from it:
  def handleErrorWith[A](fa: F[A])(f: E => F[A]): F[A]
  // Handle all errors, recovering from them:
  def handleError[A](fa: F[A])(f: E => A): F[A]
  // Test an instance of `F`,
  // failing if the predicate is not satisfied:
  def ensure[A](fa: F[A])(e: E)(f: A => Boolean): F[A]
}
```
---
* handleErrorWith via *cats.syntax.applicativError*
* ensure via *cats.syntax.monadError*

```scala
import cats.syntax.applicative._ // for pure
import cats.syntax.applicativeError._ // for raiseError etc
import cats.syntax.monadError._ // for ensure
// Alias Either to a type constructor with one parameter:
type ErrorOr[A] = Either[String, A]

val success = 42.pure[ErrorOr]
// success: ErrorOr[Int] = Right(42)
val failure = "Badness".raiseError[ErrorOr, Int]
// failure: ErrorOr[Int] = Left("Badness")
failure.handleErrorWith{
    case "Badness" => 256.pure[ErrorOr]
    case _ => ("It's not ok").raiseError[ErrorOr, Int]
}
// res4: ErrorOr[Int] = Right(256)
success.ensure("Number to low!")(_ > 1000)
// res5: ErrorOr[Int] = Left("Number to low!")
```
---
* monad execise1

```scala
import cats.MonadError
import cats.syntax.monadError._
import cats.syntax.applicativeError._
import cats.instances.all._
import scala.util.{Try, Success, Failure}

def validateAdult[F[_]](age: Int)(implicit me: MonadError[F, Throwable]): F[Int] = {
  age >= 18 match{
    case true => me.pure(age)
    case false => me.raiseError(throw new java.lang.IllegalArgumentException("Age must be greater than or equal to 18"))
  }
}
```
```scala
validateAdult[Try](18)
// res16: scala.util.Try[Int] = Success(18)

type ExceptionOr[A] = Either[Throwable, A]
// defined type alias ExceptionOr
```
```scala
scala> validateAdult[ExceptionOr](-1)
java.lang.IllegalArgumentException: Age must be greater than or equal to 18
  at .validateAdult(<console>:63)
  ... 42 elided
```
---
###Eval monad
#### eval monad with 3 types
* now: call‐by‐value which is eager and memoized;
* always: call‐by‐name which is lazy and not memoized; and
* later: call‐by‐need which is lazy and memoized.

```scala
import cats.Eval
// import cats.Eval

val now = Eval.now(math.random + 1000)
// now: cats.Eval[Double] = Now(1000.7338056777214)

val always = Eval.always(math.random + 3000)
// always: cats.Eval[Double] = cats.Always@1f64c77e

val later = Eval.later(math.random + 2000)
// later: cats.Eval[Double] = cats.Later@2673f766

now.value
// res18: Double = 1000.7338056777214

always.value
// res19: Double = 3000.831740678803

later.value
// res20: Double = 2000.4352373836941
```
---
* mapping functions are always called lazily on demand ( **def semantics**):

```scala
import cats.Eval
// import cats.Eval

val ans = for {
  a <- Eval.now{ println("Calculating A"); 40 }
  b <- Eval.always{ println("Calculating B"); 2 }
} yield {
  println("Adding A and B")
  a + b
}
// Calculating A
// ans: cats.Eval[Int] = cats.Eval$$anon$4@6a4be042

ans.value // first access
// Calculating B
// Adding A and B
// res21: Int = 42

ans.value // second access
// Calculating B
// Adding A and B
// res22: Int = 42
```
---
* memorized method

```scala
import cats.Eval
// import cats.Eval

val saying = Eval.always{ println("Step 1"); "The cat" 
  }.map{ str => println("Step 2"); s"$str sat on" 
  }.memoize.map{ str => println("Step 3"); s"$str the mat" 
}
// saying: cats.Eval[String] = cats.Eval$$anon$4@588640e4

saying.value // first access
// Step 1
// Step 2
// Step 3
// res23: String = The cat sat on the mat

saying.value // second access
// Step 3
// res24: String = The cat sat on the mat
```

---
###stack safety of evals map and flatMap
* issue example: this would cause stack overflow

```scala
def factorial(n: BigInt): BigInt =
  if(n == 1) n else n * factorial(n - 1)
factorial(50000)
// java.lang.StackOverflowError
```
* use eavl to refactor….still stack overflow

```scala
def factorial(n: BigInt): Eval[BigInt] =
  if(n == 1) {
    Eval.now(n)
  } else {
    factorial(n - 1).map(_ * n)
  }
factorial(50000).value
// java.lang.StackOverflowError
```
---
* stack overflow reason
* still making all the recursive calls to factorial before we start working with Eval's map method.
* solution: use **eavl.defer** for the rescue!!

```scala
import cats.Eval
// import cats.Eval

def factorial(n: BigInt): Eval[BigInt] =
  if(n == 1) {
    Eval.now(n)
  } else {
    Eval.defer(factorial(n - 1).map(_ * n))
  }
// factorial: (n: BigInt)cats.Eval[BigInt]

factorial(50000).value
// res25: BigInt = 33473205095971448369154760940714864779127732238104548077301003219901680221443656416973812310719169308798480438190208299893616384743066693742630572845363784038325756282123359987268244078235972356040853854441373383753568565536371168327405166076155165921406156075461294201790567479665498629242220022541553510718159801615476451810616674970217996537474972541139338191638823500630307644256874857271394651081909874909643486268589229807870031031008962861154553979911612940652327396971497211031261142860733793509687837355811830609551728906603833592532851635961730885279811957399495299450306354442478492641028990069559634883529900557676550929175475920788044807622562415165130459046318068517406766360012329556454065724225175473428183121029195715593787423641117194513...
```
* cost of eavl: It avoids consuming stack by creating a chain of function objects on the heap. There are still limits on
how deeply we can nest computations, but they are bounded by the **size of the heap rather than the stack**.
---
###writer monad
* cats.data.Writer is a monad that lets us carry a log along with a computation

ex: recording sequences of steps in multithreaded computations where standard
 imperative logging techniques can result in interleaved messages from different contexts

* *cats.data* include writer, reader, state, monad transformers and validated

```scala
import cats.data.Writer
import cats.instances.vector._ // for Monoid
Writer(Vector(
"It was the best of times",
"it was the worst of times"
), 1859)
// res0: cats.data.WriterT[cats.package.Id, Vector[String], Int] = //WriterT((Vector("It was the best of times", "it was
//the worst of //times"),1859)
```

* writer is alias of writerT

```scala
type Writer[W, A] = WriterT[Id, W, A]
```
---
####writer syntax:
* user pure + monoid

```scala
import cats.instances.vector._ // for Monoid
import cats.syntax.applicative._ // for pure
type Logged[A] = Writer[Vector[String], A]
123.pure[Logged]
// res1: Logged[Int] = WriterT((Vector(), 123))
```

* use tell for create Writer[Unit]

```scala
import cats.syntax.writer._ // for tell
Vector("msg1", "msg2", "msg3").tell
// res2: Writer[Vector[String], Unit] = WriterT(
//(Vector("msg1", "msg2", "msg3"), ())
// )
```
---
* use run for get writer both result

```scala
import cats.syntax.writer._ // for writer
val a = Writer(Vector("msg1", "msg2", "msg3"), 123)
// a: cats.data.WriterT[cats.package.Id, Vector[String], Int] = WriterT(
//(Vector("msg1", "msg2", "msg3"), 123)
// )
val b = 123.writer(Vector("msg1", "msg2", "msg3"))
// b: Writer[Vector[String], Int] = WriterT(
//(Vector("msg1", "msg2", "msg3"), 123)
// )
val aResult: Int = a.value
// aResult: Int = 123
val aLog: Vector[String] = a.written
// aLog: Vector[String] = Vector("msg1", "msg2", "msg3")
val (log, result) = b.run
// log: Vector[String] = Vector("msg1", "msg2", "msg3")
// result: Int = 123
```
---
* concat log in writer

```scala
import cats.data.Writer
// import cats.data.Writer

import cats.instances.all._
// import cats.instances.all._

import cats.syntax.writer._
// import cats.syntax.writer._

import cats.syntax.applicative._
// import cats.syntax.applicative._

type Logged[A] = Writer[Vector[String], A]
// defined type alias Logged

val writer1 = for {
  a <- 10.pure[Logged] 
  _ <- Vector("a", "b" , "c" ).tell 
  b <- 32.writer(Vector("x", "y" , "z" )) 
} yield a + b // writer1:
// writer1: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(a, b, c, x, y, z),42))

writer1.run
// res26: cats.Id[(Vector[String], Int)] = (Vector(a, b, c, x, y, z),42)
```
* use mapWritten to transform log in writer

```scala
val writer2 = writer1.mapWritten(_.map(_.toUpperCase))
// writer2: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] = WriterT((Vector(A, B, C, X, Y, Z),42))
```
---
* transform log and value simutaneously by bimap and mapBoth

```scala
val writer3 = writer1.bimap(
  log => log.map(_.toUpperCase),
  res => res * 100
)
// writer3: cats.data.WriterT[cats.package.Id, Vector[String], Int] =
// WriterT(
// (Vector("A", "B", "C", "X", "Y", "Z"), 4200)
// )
writer3.run
// res5: (Vector[String], Int) = (Vector("A", "B", "C", "X", "Y", "Z"), 4200)
val writer4 = writer1.mapBoth { (log, res) =>
  val log2 = log.map(_ + "!")
  val res2 = res * 1000
(log2, res2)
}
// writer4: cats.data.WriterT[cats.package.Id, Vector[String], Int] =
// WriterT(
// (Vector("a!", "b!", "c!", "x!", "y!", "z!"), 42000)
// )
writer4.run
// res6: (Vector[String], Int) = (
// Vector("a!", "b!", "c!", "x!", "y!", "z!"),
// 42000
// )
```
---
* reset: reset log by reset function
* swap: swap log and value

```scala
val writer5 = writer1.reset
// writer5: cats.data.WriterT[cats.package.Id, Vector[String], Int] =
// WriterT(
//(Vector(), 42)
// )
writer5.run
// res7: (Vector[String], Int) = (Vector(), 42)
val writer6 = writer1.swap
// writer6: cats.data.WriterT[cats.package.Id, Int, Vector[String]] =
// WriterT(
// (42, Vector("a", "b", "c", "x", "y", "z"))
// )
writer6.run
// res8: (Int, Vector[String]) = (42, Vector("a", "b", "c", "x", "y",
// "z"))
```
---
###reader monad
* cats.data.Reader is a monad that allows us to sequence operations that depend on
 some input. ex: common use case is **dependency injection**

*  We can create a Reader[A, B] from a function A => B using the Reader.apply constructor:

```scala
import cats.data.Reader
final case class Cat(name: String, favoriteFood: String)
```
```scala
val catName: Reader[Cat, String] = Reader(cat => cat.name)
// catName: cats.data.Reader[Cat,String] = Kleisli($$Lambda$11070/1739016115@54d1181d)

  catName.run(Cat("Garfield", "lasagne"))
// res27: cats.Id[String] = Garfield
```
---
* The power of Readers comes from their map and flatMap methods to make **sequencing operation**

```scala
val feedKitty: Reader[Cat, String] =
Reader(cat => s"Have a nice bowl of ${cat.favoriteFood}")
val greetAndFeed: Reader[Cat, String] =
for {
  greet <- greetKitty 
  feed <- feedKitty 
} yield s"$greet. $feed." 

greetAndFeed(Cat("Garfield", "lasagne" )) // res3:
cats.package.Id[String]="Hello Garfield. Have a nice bowl of // lasagne." 
greetAndFeed(Cat("Heathcliff", "junk food")) 
// res4: cats.package.Id[String]="Hello Heathcliff. Have a nice bowl
// of junk food."
```
---
* reader monad execise 1

```scala
import cats.data.Reader
import cats.Eq
import cats.instances.all._
import cats.syntax.eq._ //for eq

final case class Db(
    usernames: Map[Int, String],
    passwords: Map[String, String]
)

type DbReader[A] = Reader[Db, A]

def findUsername(userId: Int): DbReader[Option[String]] = {
    Reader(db => db.usernames.get(userId))
}

def checkPassword(usernameOpt: Option[String], password: String): DbReader[Boolean] = {
    Reader(db => usernameOpt.map(username => db.passwords.get(username).exists(i => i === password))
    .getOrElse(false)
    )
}

def checkLogin(userId: Int, password: String): DbReader[Boolean] = {
    for {
        nameOpt <- findUsername(userId)
        isValid <- checkPassword(nameOpt, password)
    } yield {
        isValid
    }
}
```
---
* reader monad execise 1(cont.)

```scala
val users = Map(
    1 -> "dade",
    2 -> "kate",
    3 -> "margo"
)
// users: scala.collection.immutable.Map[Int,String] = Map(1 -> dade, 2 -> kate, 3 -> margo)

val passwords = Map(
  "dade" -> "zerocool",
  "kate" -> "acidburn",
  "margo" -> "secret"
)
// passwords: scala.collection.immutable.Map[String,String] = Map(dade -> zerocool, kate -> acidburn, margo -> secret)

val db = Db(users, passwords)
// db: Db = Db(Map(1 -> dade, 2 -> kate, 3 -> margo),Map(dade -> zerocool, kate -> acidburn, margo -> secret))

checkLogin(1, "zerocool").run(db)
// res28: cats.Id[Boolean] = true

checkLogin(4, "davinci").run(db)
// res29: cats.Id[Boolean] = false
```
---
#### when to use Reader?
* how many ways to do dependency injection?
  1. methods with multiple parameter lists
  2. implicit parameters and type classes
  3. cake pattern and DI frameworks(google guice)

* Readers are most useful in situations where:
  1. we are constructing a program that can easily be represented by a function;
  2. we need to defer injection of a known parameter or set of parameters;
  3. we want to be able to test parts of the program in isolation.
---
###State Monad
* *cats.data.State* allows us to pass additional state around as part of a computation.
type **S => (S, A)** . S is the type of the state and A is the type of the result.

```scala
import cats.data.State
// import cats.data.State

val a = State[Int, String]{ state =>
  (state, s"The state is $state")
}
// a: cats.data.State[Int,String] = cats.data.IndexedStateT@43f4db7a
```
* transforms an input state to an output state;
* computes a result.
---
* run, runS, runA

```scala
// Get the state and the result:
val (state, result) = a.run(10).value
// state: Int = 10
// result: String = "The state is 10"
// Get the state, ignore the result:
val justTheState = a.runS(10).value
// justTheState: Int = 10
// Get the result, ignore the state:
val justTheResult = a.runA(10).value
// justTheResult: String = "The state is 10"
```
---
* compose and transform state monad

```scala
val step1 = State[Int, String]{ num =>
val ans = num + 1
(ans, s"Result of step1: $ans")
}
val step2 = State[Int, String]{ num =>
val ans = num * 2
(ans, s"Result of step2: $ans")
}
val both = for {
  a <- step1 
  b <- step2 
} yield (a, b) 
val (state, result)=both.run(20).value 
// state: Int=42 
// result: (String,  String)=("Result of step1: 21", "Result of step2: 42" )
```
---
* Cats provides several convenience constructors for creating primitive steps:
  * get extracts the state as the result;
  * set updates the state and returns unit as the result;
  * pure ignores the state and returns a supplied result;
  * inspect extracts the state via a transformation function;
  * modify updates the state using an update function.
```scala
val getDemo = State.get[Int]
// getDemo: State[Int, Int] = cats.data.IndexedStateT@796af713
getDemo.run(10).value
// res1: (Int, Int) = (10, 10)
val setDemo = State.set[Int](30)
// setDemo: State[Int, Unit] = cats.data.IndexedStateT@f9e66fa
setDemo.run(10).value
// res2: (Int, Unit) = (30, ())
val pureDemo = State.pure[Int, String]("Result")
// pureDemo: State[Int, String] = cats.data.IndexedStateT@439e3ee4
pureDemo.run(10).value
// res3: (Int, String) = (10, "Result")
val inspectDemo = State.inspect[Int, String](x => s"${x}!")
// inspectDemo: State[Int, String] = cats.data.IndexedStateT@77263be4
inspectDemo.run(10).value
// res4: (Int, String) = (10, "10!")
val modifyDemo = State.modify[Int](_ + 1)
// modifyDemo: State[Int, Unit] = cats.data.IndexedStateT@44ddcbfc
modifyDemo.run(10).value
// res5: (Int, Unit) = (11, ())
```
---
```scala
import cats.data.State
// import cats.data.State

import State._
// import State._

val program: State[Int, (Int, Int, Int)] = for {
  a <- get[Int] 
  _ <- set[Int](a + 1) 
  b <- get[Int] 
  _ <- modify[Int](_ + 1) 
  c <- inspect[Int, Int](_ * 1000) 
} yield (a, b, c) 
// program: cats.data.State[Int,(Int, Int, Int)] = cats.data.IndexedStateT@2fe749c

val (state, result)=program.run(1).value 
// state: Int = 3
// result: (Int, Int, Int) = (1,2,3000)
```
---
* defining custom monad
* implement: pure, flatMap, tailRecM
  * ex: Option:

```scala
import cats.Monad
import scala.annotation.tailrec
val optionMonad = new Monad[Option] {
  def flatMap[A, B](opt: Option[A])(fn: A => Option[B]): Option[B] =
    opt flatMap fn
  
  def pure[A](opt: A): Option[A] =
    Some(opt)
  
  @tailrec
  def tailRecM[A, B](a: A)(fn: A => Option[Either[A, B]]): Option[B] =
    fn(a) match {
      case None => None
      case Some(Left(a1)) => tailRecM(a1)(fn)
      case Some(Right(b)) => Some(b)
    }
  }
}
```
---
* flatMap syntax is not stack safe

```scala
import cats.syntax.flatMap._ // For flatMap
def retry[F[_]: Monad, A](start: A)(f: A => F[A]): F[A] =
  f(start).flatMap{ a =>
    retry(a)(f)
  }
```
```scala
retry(100000)(a => if(a == 0) None else Some(a - 1))
//get StackOverflowError .
```

* use tail recursion to fix it

```scala
import cats.syntax.functor._ // for map
def retryTailRecM[F[_]: Monad, A](start: A)(f: A => F[A]): F[A] =
Monad[F].tailRecM(start){ a =>
f(a).map(a2 => Left(a2))
}

retryTailRecM(100000)(a => if(a == 0) None else Some(a - 1))
// res2: Option[Int] = None
```
---
* some convinent util: iterateWhileM

```scala
import cats.syntax.monad._ // for iterateWhileM
// import cats.syntax.monad._

def retryM[F[_]: Monad, A](start: A)(f: A => F[A]): F[A] =
  start.iterateWhileM(f)(a => true)
// retryM: [F[_], A](start: A)(f: A => F[A])(implicit evidence$1: cats.Monad[F])F[A]

retryM(100000)(a => if(a == 0) None else Some(a - 1))
// res30: Option[Int] = None
```
* monad for sequencing operation, ex:
  * Option represents a computation that can fail without an error message,
  * Either represents computations that can fail with a message,
  * List represents multiple possible results, and
  * Future represents a computation that may produce a value at some point in the future.
  * some custom: Id , Reader , Writer , and State

---
###monad transformers
* Cats defines transformers for a variety of monads, 
* each providing the extra knowledge we need to compose that monad with others.
* The type signatures of monad transformers are written **from the inside out**, 
so an **EitherT[Option, String, A]** is a wrapper for an **Option[Either[String, A]]**

ex: EitherT composes Either with other monads, OptionT composes Option
```scala
import cats.data.OptionT
type ListOption[A] = OptionT[List, A]

import cats.instances.list._
// for Monad
import cats.syntax.applicative._ // for pure
val result1: ListOption[Int] = OptionT(List(Option(10)))
// result1: ListOption[Int] = OptionT(List(Some(10)))
val result2: ListOption[Int] = 32.pure[ListOption]
// result2: ListOption[Int] = OptionT(List(Some(32)))
result1.flatMap { (x: Int) =>
  result2.map { (y: Int) =>
    x + y
  }
}
// res1: OptionT[List, Int] = OptionT(List(Some(42)))
```
---
* The combined map and flatMap methods allow us to use both component monads 
without having to recursively unpack and repack values at each stage in the computation.

* The main concepts we have to cover to understand monad transformers are:
  * the available transformer classes;
  * how to build stacks of monads using transformers;
  * how to construct instances of a monad stack; and
  * how to pull apart a stack to access the wrapped monads.

* transformer class
  * cats.data.OptionT for Option ;
  * cats.data.EitherT for Either ;
  * cats.data.ReaderT ( == Kleisli) for Reader ;
  * cats.data.WriterT for Writer ;
  * cats.data.StateT for State ;
  * cats.data.IdT for the Id monad.
---
 * example of 2 types constructor: Either[String, Option]

```scala
// Alias Either to a type constructor with one parameter:
type ErrorOr[A] = Either[String, A]
// Build our final monad stack using OptionT:
type ErrorOrOption[A] = OptionT[ErrorOr, A]

import cats.instances.either._ // for Monad
val a = 10.pure[ErrorOrOption]
// a: ErrorOrOption[Int] = OptionT(Right(Some(10)))
val b = 32.pure[ErrorOrOption]
// b: ErrorOrOption[Int] = OptionT(Right(Some(32)))
val c = a.flatMap(x => b.map(y => x + y))
// c: OptionT[ErrorOr, Int] = OptionT(Right(Some(42)))
```
---
* example of Future of an Either of Option . Once again we build this from 
the inside out with an OptionT of an EitherT of Future

```scala
import scala.concurrent.Future
import cats.data.{EitherT, OptionT}
type FutureEither[A] = EitherT[Future, String, A]
type FutureEitherOption[A] = OptionT[FutureEither, A]

import cats.instances.future._ // for Monad
import scala.concurrent.Await
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration._

```
```scala
val futureEitherOr: FutureEitherOption[Int] = for {
  a <- 10.pure[FutureEitherOption] 
  b <- 32.pure[FutureEitherOption] 
} yield a + b
// futureEitherOr: FutureEitherOption[Int] = OptionT(EitherT(Future(<not completed>)))
```
---
* NOTE: **Kind Projector** plugin can help for enhances Scala’s type syntax to make it easier to
define partially applied type constructors, 
* Kind Projector is a syntax sugar for making anonymous type declaration as this type just used once
  * ex:

```scala
import cats.instances.option._ // for Monad 
// import cats.instances.option._

123.pure[EitherT[Option, String, *]]
// res31: cats.data.EitherT[Option,String,Int] = EitherT(Some(Right(123)))
```
* [kind projector](https://github.com/typelevel/kind-projector)
---
* use value to get untransformed stack once layer

```scala
// Extracting the untransformed monad stack:
errorStack1.value
// res4: ErrorOr[Option[Int]] = Right(Some(10))
// Mapping over the Either in the stack:
errorStack2.value.map(_.getOrElse(-1))
// res5: Either[String, Int] = Right(32)
```

* to unpack all may need to call value many times

```scala
futureEitherOr
// res6: FutureEitherOption[Int] = OptionT(
//EitherT(Future(Success(Right(Some(42)))))
// )
val intermediate = futureEitherOr.value
// intermediate: FutureEither[Option[Int]] = EitherT(
//Future(Success(Right(Some(42))))
// )
val stack = intermediate.value
// stack: Future[Either[String, Option[Int]]] = Future(Success(Right(
// Some(42))))
Await.result(stack, 1.second)
// res7: Either[String, Option[Int]] = Right(Some(42))
```
* default transformer instances in cats

```scala
type Reader[E, A] = ReaderT[Id, E, A] // = Kleisli[Id, E, A]
type Writer[W, A] = WriterT[Id, W, A]
type State[S, A] = StateT[Id, S, A]
```
---
* easier way to just use transformer in local
```scala
import cats.data.Writer
type Logged[A] = Writer[List[String], A]
// Methods generally return untransformed stacks:
def parseNumber(str: String): Logged[Option[Int]] =
  util.Try(str.toInt).toOption match {
    case Some(num) => Writer(List(s"Read $str"), Some(num))
    case None => Writer(List(s"Failed on $str"), None)
  }
// Consumers use monad transformers locally to simplify composition:
def addAll(a: String, b: String, c: String): Logged[Option[Int]] = {
  import cats.data.OptionT
  val result = for {
    a <- OptionT(parseNumber(a))
    b <- OptionT(parseNumber(b))
    c <- OptionT(parseNumber(c))
  } yield a + b + c
  
  result.value
}
// This approach doesn't force OptionT on other users' code:
val result1 = addAll("1", "2", "3")
// result1: Logged[Option[Int]] = WriterT(
//(List("Read 1", "Read 2", "Read 3"), Some(6))
// )
val result2 = addAll("1", "a", "3")
// result2: Logged[Option[Int]] = WriterT(
//(List("Read 1", "Failed on a"), None)
// )
```
---
### semigroupal and applicative
* request: monad is **sequencing operation** and **fail fast**, in some case we want to be **concurrent** and collect all fail
  * ex1: web form want to collect all error rather than fail fast
  * ex2: future want to be runned parallel
* We need a weaker construct one that doesn’t guarantee sequencing—
to achieve the result we want. we will look at three type classes that support this pattern:
  * **Semigroupal** encompasses the notion of composing pairs of contexts. Cats provides a **cats.syntax.apply** module 
  that makes use of Semigroupal and Functor to allow users to sequence functions with multiple arguments.
  * **Parallel** converts types with a Monad instance to a related type with a Semigroupal instance.
  * **Applicative** extends Semigroupal and Functor . It provides a way of applying functions to parameters within a context. 
  Applicative is the source of the pure method we introduced in Chapter 4.
---
* Semigroupal: join two context, behavior likes zip
  ```scala
  trait Semigroupal[F[_]] {
    def product[A, B](fa: F[A], fb: F[B]): F[(A, B)]
  }
```
  * ex:

```scala
import cats.Semigroupal
import cats.instances.option._ // for Semigroupal
Semigroupal[Option].product(Some(123), Some("abc"))
// res1: Option[(Int, String)] = Some((123, "abc"))
Semigroupal[Option].product(None, Some("abc"))
// res2: Option[Tuple2[Nothing, String]] = None
Semigroupal[Option].product(Some(123), None)
// res3: Option[Tuple2[Int, Nothing]] = None
```
* clarify: where Semigroup is for joining values

```scala
trait Semigroup[A] {
  def combine(x: A, y: A): A
}
```
---
* semigroupal tuple2 through tuple22

```scala
import cats.instances.option._ // for Semigroupal
Semigroupal.tuple3(Option(1), Option(2), Option(3))
// res4: Option[(Int, Int, Int)] = Some((1, 2, 3))
Semigroupal.tuple3(Option(1), Option(2), Option.empty[Int])
// res5: Option[(Int, Int, Int)] = None
```
* semigroup map2 to map22

```scala
Semigroupal.map3(Option(1), Option(2), Option(3))(_ + _ + _)
// res6: Option[Int] = Some(6)
Semigroupal.map2(Option(1), Option.empty[Int])(_ + _)
// res7: Option[Int] = None
```
* There are also methods contramap2 through contramap22 and imap2 through imap22
* **import cats.syntax.apply._** for mapN
---
* Semigroupal Laws: the product method must be associative.
  ```scala
  product(a, product(b, c)) == product(product(a, b), c)
```

* tupled method
  ```scala
  (Option(123), Option("abc"), Option(true)).tupled
// res9: Option[(Int, String, Boolean)] = Some((123, "abc", true))
```

* mapN
  ```scala
  final case class Cat(name: String, born: Int, color: String)
(
  Option("Garfield"),
  Option(1978),
  Option("Orange & black")
).mapN(Cat.apply)
// res10: Option[Cat] = Some(Cat("Garfield", 1978, "Orange & black"))
```
---
* sometimes, mapN is effective than monad transformer,ex:

```scala
import cats.effect.IO
import cats.implicits._

//interchangable with e.g. Monix's Task
type Query[T] = IO[Option[T]]

def defineMead(qName: Query[String],
               qHoneyRatio: Query[Double],
               qAgingYears: Query[Double]): Query[Mead] =
  (for {
    name       <- OptionT(qName)
    honeyRatio <- OptionT(qHoneyRatio)
    agingYears <- OptionT(qAgingYears)
  } yield Mead(name, honeyRatio, agingYears)).value

def defineMead2(qName: Query[String],
                qHoneyRatio: Query[Double],
                qAgingYears: Query[Double]): Query[Mead] =
  for {
    name       <- qName
    honeyRatio <- qHoneyRatio
    agingYears <- qAgingYears
  } yield (name, honeyRatio, agingYears).mapN(Mead)
```
---
* mapN is also type checked
  ```scala 
val add: (Int, Int) => Int = (a, b) => a + b
// add: (Int, Int) => Int = <function2>
(Option(1), Option(2), Option(3)).mapN(add)
// error: ':' expected but '(' found.
// error: identifier expected but '}' found.
(Option("cats"), Option(true)).mapN(add)
// error: ':' expected but '(' found.
// error: identifier expected but '}' found.
```

* imapN on semigroupal
  ```scala
import cats.Monoid
import cats.instances.int._ // for Monoid
import cats.instances.invariant._ // for Semigroupal
import cats.instances.list._ // for Monoid
import cats.instances.string._ // for Monoid
import cats.syntax.apply._ // for imapN
final case class Cat(name: String,
  yearOfBirth: Int,
  favoriteFoods: List[String]
)
val tupleToCat: (String, Int, List[String]) => Cat = Cat.apply _
val catToTuple: Cat => (String, Int, List[String]) =
  cat => (cat.name, cat.yearOfBirth, cat.favoriteFoods)
implicit val catMonoid: Monoid[Cat] = (
  Monoid[String],
  Monoid[Int],
  Monoid[List[String]]
).imapN(tupleToCat)(catToTuple)
```
---
* add object together
  ```scala
import cats.syntax.semigroup._ // for |+|
val garfield = Cat("Garfield", 1978, List("Lasagne"))
val heathcliff = Cat("Heathcliff", 1988, List("Junk Food"))
garfield |+| heathcliff
// res14: Cat = Cat("GarfieldHeathcliff", 3966, List("Lasagne", "Junk Food"))
```

* Future provide **parallel** as opposed to sequential execution:
  ```scala
import cats.Semigroupal
import cats.instances.future._ // for Semigroupal
import scala.concurrent._
import scala.concurrent.duration._
import scala.concurrent.ExecutionContext.Implicits.global
val futurePair = Semigroupal[Future]
.product(Future("Hello"), Future(123))
Await.result(futurePair, 1.second)
// res0: (String, Int) = ("Hello", 123)
```
---
* use mapN on future, to zip fixed numbers of Futures
  
```scala
  import cats.syntax.apply._ // for mapN
// import cats.syntax.apply._

case class Cat(
name: String,
yearOfBirth: Int,
favoriteFoods: List[String]
)
// defined class Cat

val futureCat = (
  Future("Garfield"),
  Future(1978),
  Future(List("Lasagne"))
).mapN(Cat.apply)
// futureCat: scala.concurrent.Future[Cat] = Future(<not completed>)

Await.result(futureCat, 1.second)
// res32: Cat = Cat(Garfield,1978,List(Lasagne))
```
---
* list: Combining Lists with Semigroupal produces some potentially unexpected results
  * ex:

```scala
import cats.Semigroupal
// import cats.Semigroupal

import cats.instances.list._ // for Semigroupal
// import cats.instances.list._

Semigroupal[List].product(List(1, 2), List(3, 4))
// res33: List[(Int, Int)] = List((1,3), (1,4), (2,3), (2,4))
```

* Either use product still get fail fast result:
  
```scala
import cats.instances.either._ // for Semigroupal
// import cats.instances.either._

type ErrorOr[A] = Either[Vector[String], A]
// defined type alias ErrorOr

Semigroupal[ErrorOr].product(
  Left(Vector("Error 1")),
  Left(Vector("Error 2"))
)
// res34: ErrorOr[(Nothing, Nothing)] = Left(Vector(Error 1))
```
---
* The reason for the surprising results for List and Either is that they are both monads.
* If we have a monad we can implement product as follows.

```scala
import cats.Monad
import cats.syntax.functor._ // for map
import cats.syntax.flatMap._ // for flatmap
def product[F[_]: Monad, A, B](fa: F[A], fb: F[B]): F[(A,B)] =
  fa.flatMap(a =>
    fb.map(b =>
      (a, b)
    )
  )
```
* flatMap provides sequential ordering, so product provides the same….
* how to fix it?
  * create useful data types that have instances of Semigroupal (and Applicative )
    but not Monad .=> The **Parallel type class** for the rescue

---
####The Parallel type class
* from

```scala
import cats.syntax.apply._ // for tupled
import cats.instances.vector._ // for Semigroup on Vector
(error1, error2).tupled
// res1: ErrorOr[(Int, Int)] = Left(Vector("Error 1"))
```
* to

```scala
import cats.syntax.parallel._ // for parTupled
(error1, error2).parTupled
// res2: ErrorOr[(Int, Int)] = Left(Vector("Error 1", "Error 2"))
```
---
* more example on list

```scala
import cats.instances.list._ // for Semigroup on List
type ErrorOrList[A] = Either[List[String], A]
val errStr1: ErrorOrList[Int] = Left(List("error 1"))
val errStr2: ErrorOrList[Int] = Left(List("error 2"))
(errStr1, errStr2).parTupled
// res3: ErrorOrList[(Int, Int)] = Left(List("error 1", "error 2"))
```

* most commonly used is parMapN

```scala
val success1: ErrorOr[Int] = Right(1)
val success2: ErrorOr[Int] = Right(2)
val addTwo = (x: Int, y: Int) => x + y
(error1, error2).parMapN(addTwo)
// res4: ErrorOr[Int] = Left(Vector("Error 1", "Error 2"))
(success1, success2).parMapN(addTwo)
// res5: ErrorOr[Int] = Right(3)
```
---
* how Parallel works

```scala
trait Parallel[M[_]] {
  type F[_]
  def applicative: Applicative[F]
  def monad: Monad[M]
  def parallel: ~>[M, F] //FunctionK
}
```
* there must be a Monad instance for M ;
* there is a related type constructor F that has an Applicative instance;
* we can convert M to F .
  * **FunctionK M ~> F** is a function from a value with type M[A] to a value with type F[A]
* ex: FunctionK that converts an Option to a List

```scala
import cats.arrow.FunctionK
object optionToList extends FunctionK[Option, List] {
def apply[A](fa: Option[A]): List[A] =
  fa match {
    case None => List.empty[A]
    case Some(a) => List(a)
  }
}
optionToList(Some(1))
// res6: List[Int] = List(1)
optionToList(None)
// res7: List[Nothing] = List()
```
---
* Does List have a Parallel instance?yes

```scala
import cats.instances.list._
// import cats.instances.list._

import cats.syntax.parallel._
// import cats.syntax.parallel._

(List(1, 2), List(3, 4)).tupled
// res35: List[(Int, Int)] = List((1,3), (1,4), (2,3), (2,4))

(List(1, 2), List(3, 4)).parTupled
// res36: List[(Int, Int)] = List((1,3), (2,4))
```

* apply and applicative

```scala
trait Apply[F[_]] extends Semigroupal[F] with Functor[F] {
  def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]
  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
  ap(map(fa)(a => (b: B) => (a, b)))(fb)
}

trait Applicative[F[_]] extends Apply[F] {
  def pure[A](a: A): F[A]
}
```
---
###Traverse and Foldable
* Foldable abstracts the familiar foldLeft and foldRight operations;
* Traverse is a higher‐level abstraction that uses Applicatives to iterate with less pain than folding.

* fold example

```scala
def show[A](list: List[A]): String =
list.foldLeft("nil")((accum, item) => s"$item then $accum")
show(Nil)
// res0: String = "nil"
show(List(1, 2, 3))
// res1: String = "3 then 2 then 1 then nil"
```
---
* foldLeft and foldRight are equivalent if our binary operation is associative.ex:

```scala
List(1, 2, 3).foldLeft(0)(_ + _)
// res37: Int = 6

List(1, 2, 3).foldRight(0)(_ + _)
// res38: Int = 6
```
* not associative case

```scala
List(1, 2, 3).foldLeft(0)(_ - _)
// res39: Int = -6

List(1, 2, 3).foldRight(0)(_ - _)
// res40: Int = 2
```
---
* Foldable example: list foldLeft

```scala
import cats.Foldable
// import cats.Foldable

import cats.instances.list._ // for Foldable
// import cats.instances.list._

val ints = List(1, 2, 3)
// ints: List[Int] = List(1, 2, 3)

Foldable[List].foldLeft(ints, 0)(_ + _)
// res41: Int = 6
```

* option foldLeft

```scala
import cats.instances.option._ // for Foldable
// import cats.instances.option._

val maybeInt = Option(123)
// maybeInt: Option[Int] = Some(123)

Foldable[Option].foldLeft(maybeInt, 10)(_ * _)
// res42: Int = 1230
```
---
* foldRight of Foldable with Eval monad(for stack safe)
* original foldRight is not stack safe, especially for lazyList

```scala
def foldRight[A, B](fa: F[A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B]
```

* original foldRight

```scala
import 
def bigData = (1 to 100000).to(LazyList)
bigData.foldRight(0L)(_ + _)
// java.lang.StackOverflowError ...
```
* LazyList is not found on scala2.12
* clarify:In standard scala lib, The most commonly used collection types, such as List and Vector , provide stack safe
implementations of foldRight :

```scala
(1 to 100000).toList.foldRight(0L)(_ + _)
// res43: Long = 5000050000

(1 to 100000).toVector.foldRight(0L)(_ + _)
// res44: Long = 5000050000
```
---
* foldRight with eval

```scala
//only work after scala2.13
import cats.instances.lazyList._ // for Foldable
val eval: Eval[Long] =
Foldable[LazyList].foldRight(bigData, Eval.now(0L)) { (num, eval) =>
eval.map(_ + num)
}
eval.value
// res3: Long = 5000050000L
```
---
* In addition to these familiar methods, Cats provides two methods that make use of Monoids :
  * **combineAll (and its alias fold )** combines all elements in the sequence using their Monoid ;
  * **foldMap** maps a user‐supplied function over the sequence and combines the results using a Monoid .
* ex:

```scala
import cats.instances.int._ // for Monoid
// import cats.instances.int._

Foldable[List].combineAll(List(1, 2, 3))
// res45: Int = 6
```

* foldMap, map and concat

```scala
import cats.instances.string._ // for Monoid
// import cats.instances.string._

Foldable[List].foldMap(List(1, 2, 3))(_.toString)
// res46: String = 123
```
---
* compose Foldables

```scala
import cats.instances.vector._ // for Monoid
// import cats.instances.vector._

val ints = List(Vector(1, 2, 3), Vector(4, 5, 6))
// ints: List[scala.collection.immutable.Vector[Int]] = List(Vector(1, 2, 3), Vector(4, 5, 6))

(Foldable[List] compose Foldable[Vector]).combineAll(ints)
// res47: Int = 21
```

syntax for foldable

```scala
import cats.syntax.foldable._ // for combineAll and foldMap
// import cats.syntax.foldable._

List(1, 2, 3).combineAll
// res48: Int = 6

List(1, 2, 3).foldMap(_.toString)
// res49: String = 123
```
---
### Traverse
* Traverse type class is a higher level tool that leverages Applicatives to provide a more convenient, more lawful,
pattern for iteration.

* Future.traverse in the standard library looks like this:

```scala
def traverse[A, B](values: List[A])(func: A => Future[B]): Future[List[B]] =
  values.foldLeft(Future(List.empty[B])) { (accum, host) =>
val item = func(host)
for {
  accum <- accum 
  item <- item 
} yield accum :+ item } 
```
* high level interface 
  * start with a List[A] ; 
  * provide a function A=> Future[B] ;
  * end up with a Future[List[B]] .
---
* Future.sequence is extended from traverse
  
```scala
def sequence[B](futures: List[Future[B]]): Future[List[B]] =
  traverse(futures)(identity)
```
* start with a List[Future[A]] ;
*  end up with a Future[List[A]] .
---
* Cats’ Traverse type class generalises these patterns to work with any type
of Applicative : Future , Option , Validated , and so on

```scala
import cats.Applicative
import cats.syntax.applicative._ // for pure
def listTraverse[F[_]: Applicative, A, B](list: List[A])(func: A => F[B]): F[List[B]] =
  list.foldLeft(List.empty[B].pure[F]) { (accum, item) =>
    (accum, func(item)).mapN(_ :+ _)
  }
def listSequence[F[_]: Applicative, B](list: List[F[B]]): F[List[B]] =
  listTraverse(list)(identity)
```
---
* use traverse with validated

```scala
import cats.data.Validated
import cats.instances.list._ // for Monoid

type ErrorsOr[A] = Validated[List[String], A]

def process(inputs: List[Int]): ErrorsOr[List[Int]] =
  listTraverse(inputs) { n =>
    if(n % 2 == 0) {
      Validated.valid(n)
    } else {
      Validated.invalid(List(s"$n is not even"))
    }
}
```
```scala
process(List(2, 4, 6))
// res50: ErrorsOr[List[Int]] = Valid(List(2, 4, 6))

process(List(1, 2, 3))
// res51: ErrorsOr[List[Int]] = Invalid(List(1 is not even, 3 is not even))
```
---
* Traverse definition

```scala
package cats
trait Traverse[F[_]] {
  def traverse[G[_]: Applicative, A, B](inputs: F[A])(func: A => G[B]): G[F[B]]
  def sequence[G[_]: Applicative, B](inputs: F[G[B]]): G[F[B]] =
    traverse(inputs)(identity)
}
```
---
* Traverse example

```scala
import cats.Traverse
import cats.instances.future._ // for Applicative
import cats.instances.list._ // for Traverse

import scala.concurrent._
import scala.concurrent.duration._
import scala.concurrent.ExecutionContext.Implicits.global
val hostnames = List(
  "alpha.example.com",
  "beta.example.com",
  "gamma.demo.com"
)
def getUptime(hostname: String): Future[Int] =
  Future(hostname.length * 60) // just for demonstration
```
```scala
val totalUptime: Future[List[Int]] = Traverse[List].traverse(hostnames)(getUptime)
// totalUptime: scala.concurrent.Future[List[Int]] = Future(Success(List(1020, 960, 840)))

Await.result(totalUptime, 1.second)
// res52: List[Int] = List(1020, 960, 840)

val numbers = List(Future(1), Future(2), Future(3))
// numbers: List[scala.concurrent.Future[Int]] = List(Future(Success(1)), Future(Success(2)), Future(Success(3)))

val numbers2: Future[List[Int]] = Traverse[List].sequence(numbers)
// numbers2: scala.concurrent.Future[List[Int]] = Future(<not completed>)

Await.result(numbers2, 1.second)
// res53: List[Int] = List(1, 2, 3)
```
---
* traverse syntax sugar

```scala
import cats.syntax.traverse._ // for sequence and traverse
// import cats.syntax.traverse._

Await.result(hostnames.traverse(getUptime), 1.second)
// res54: List[Int] = List(1020, 960, 840)

Await.result(numbers.sequence, 1.second)
// res55: List[Int] = List(1, 2, 3)
```
---
###Reference
* [scala with cats2](https://www.scalawithcats.com/ "www.scalawithcats.com")
* [cats FAQ](https://typelevel.org/cats/faq.html)
* [Useful Ammonite snippets](https://gist.github.com/MateuszKubuszok/a80503b28f289f08f2f6c6c70871e8d3#partial-unification)
* [9-tips-about-using-cats-in-scala-you-might-want-to-know](https://blog.softwaremill.com/9-tips-about-using-cats-in-scala-you-might-want-to-know-e1bafd365f88)
* [monad-transformers-for-the-working-programmer](https://blog.buildo.io/monad-transformers-for-the-working-programmer-aa7e981190e7)
* [flinters engineers blog](https://labs.septeni.co.jp/entry/functional-brothers)
* [Monad Transformers for the working programmer | by Gabriele Petronella](https://speakerdeck.com/danielasfregola/scalamatsuri-2018-a-pragmatic-introduction-to-category-theory)
* [DanielaSfregola github](https://github.com/DanielaSfregola)

---
class: center, middle

# Thanks!
Code and slides at `chenghsienwen/scalacatexecise` on GitHub

## Questions?





 </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
       remark.macros.scale = function (percentage) {
          var url = this;
          return '<img src="' + url + '" style="width: ' + percentage + '" />';
        };
        var slideshow = remark.create();
    </script>
  </body>
</html>
