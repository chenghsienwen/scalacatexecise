<!DOCTYPE html>
<html>
  <head>
    <title>scala cat execise</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
      .image-50 img {
        width: 50%;
      }
    </style>
  </head>
  <body>
    <textarea id="source">




class: center, middle

# scala cat execise
Chenghsien Wen • `@chenghsienwen`


???
- notes here
- see https://remarkjs.com/#1
- see https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet

---
# execise from scala with cats 2 book

[free download](https://www.scalawithcats.com/ "www.scalawithcats.com")

![:scale 90%](resources/scala-with-cats2.jpeg)

---
# Agenda
##  what is category theory?
##  what is type class in scala?
##  cats import structure
##  main type class in cats
---
# what is category theory?
### how things compose and transform
![:scale 60%](resources/category-theory-graph.png)
---
# type class in scala
```scala
trait Printable[A] {
  def format(a: A): String
}

object PrintableInstance {
  implicit val strPrint: Printable[String] = new Printable[String] {
    def format(a: String): String = a
  }
  implicit val intPrint: Printable[Int] = new Printable[Int] {
    def format(a: Int): String = a.toString
  }
}

object Printable {
  def format[A](a: A)(implicit p: Printable[A]): String = p.format(a)
}

object PrintableSyntax {
  implicit class PrintableOps[A](a: A)(implicit p: Printable[A]) {
    def show: String = p.format(a)
  }
}
```
---
#run show
```scala
import com.vpon.cat.Printable
import com.vpon.cat.PrintableSyntax.PrintableOps
import com.vpon.cat.PrintableInstance._
```
```scala
Printable.format("xxx")
// res0: String = xxx

"aaa".show
// res1: String = aaa
```
---
# add one more instance
```scala
import com.vpon.cat.Printable
import com.vpon.cat.PrintableSyntax.PrintableOps
import com.vpon.cat.PrintableInstance._

final case class Cat(name: String, age: Int, color: String)

implicit val catPrint: Printable[Cat] = new Printable[Cat] {
  def format(cat: Cat): String = {
    val name = Printable.format(cat.name)
    val age = Printable.format(cat.age)
    val color = Printable.format(cat.color)
    s"$name is a $age year-old $color cat."
  }
}
```
```scala
println(Printable.format("xxx"))
// xxx

println("aaa".show)
// aaa

println(Cat("meme", 5, "yellow").show)
// meme is a 5 year-old yellow cat.
```
---
# show type class in cats

```scala
//ref:https://typelevel.org/cats/typeclasses/show.html
import cats.Show
import cats.syntax.show._


case class Person(name: String, age: Int)
implicit val showPerson: Show[Person] = Show.show(person => s"name: ${person.name}, age: ${person.age}")
```
```scala
println(Person("John", 31).show)
// name: John, age: 31
```
---
#Eq
* issue on **==**
```scala
List(1, 2, 3).map(Option(_)).filter(item => item == 1)
// <console>:29: warning: Option[Int] and Int are unrelated: they will most likely never compare equal
//        List(1, 2, 3).map(Option(_)).filter(item => item == 1)
//                                                         ^
// res7: List[Option[Int]] = List()
```
* use cats eq for **type safe** equality
* === compares two objects for equality;
* =!= compares two objects for inequality.
```scala
import cats.Eq
import cats.instances.all._
import cats.syntax.eq._
```
```scala
scala> List(1, 2, 3).map(Option(_)).filter(item => item === 1)
<console>:36: error: type mismatch;
 found   : Int(1)
 required: Option[Int]
       List(1, 2, 3).map(Option(_)).filter(item => item === 1)
                                                            ^
```
---
#cats import structure
* cats.x for core/"kernel" types;
* cats.data for data types such as **Validated, monad transformers**, etc.;
* cats.syntax.x._ for extension method support, so you can call e.g. sth.asRight, sth.pure, and so on;
* cats.instances.x._ for actual implicit scope import of implementation of the various typeclasses for specific types, so
that when you call e.g. sth.pure you don’t get an "implicit not found" error.
* you can use *import cats.implicits._* to include all instances and syntax
---
#main type class in cats
* Monoid and Semigroup 
* Functor 
* Monad and Moand transforer
* Semigroupal and Applicative 
* Traverse and Foldable
---
###monad type class hierachy
![:scale 75%](resources/monad-type-class-hierachy.jpeg)
---
###definition of monoid: a monoid for a type A is:
* an operation combine with type (A, A) => A
* an element empty of type A
```scala
trait Monoid[A] {
  def combine(x: A, y: A): A
  def empty: A
}
```

### monoids must formally obey several laws. For all values x , y , and z , in A 
* combine must be associative and
* empty must be an identity element:

---
### definition of semigroup: just combine part of monoid
```scala
trait Semigroup[A] {
  def combine(x: A, y: A): A
}
trait Monoid[A] extends Semigroup[A] {
  def empty: A
}
```
---
### monoid execise1
```scala
import cats.Monoid
import cats.instances.all._
import cats.syntax.semigroup._
import cats.syntax.option._

```
```scala
val c1 = Set(1, 2) |+| Set(2, 3)
// c1: scala.collection.immutable.Set[Int] = Set(1, 2, 3)

val c2 = Set("A", "B") |+| Set("B", "C")
// c2: scala.collection.immutable.Set[String] = Set(A, B, C)

val c3 = Set(1.some, 2.some) |+| Set(2.some, 3.some)
// c3: scala.collection.immutable.Set[Option[Int]] = Set(Some(1), Some(2), Some(3))
```
### monoid execise2 on next page
---
```scala
import cats.Monoid
import cats.instances.all._
import cats.syntax.semigroup._
import cats.syntax.option._

case class Order(totalCost: Double, quantity: Double)
implicit val orderMono = new Monoid[Order] {
  def combine(x: Order, y: Order): Order = x.copy(totalCost = x.totalCost |+| y.totalCost, quantity = x.quantity |+| y.quantity)
  def empty: Order = Order(0, 0)
}
def addInt(items: List[Int]): Int = items.foldLeft(Monoid[Int].empty)((a, b) => a |+| b)

def add[A](items: List[A])(implicit monoid: Monoid[A]): A = items.foldLeft(monoid.empty)((a, b) => a |+| b)
```
```scala
val list1 = List(Some(1), Some(2), None) 
// list1: List[Option[Int]] = List(Some(1), Some(2), None)

val list2 = (0 to 5).map(i => Order(i, i)).toList
// <console>:58: warning: implicit numeric widening
//        val list2 = (0 to 5).map(i => Order(i, i)).toList
//                                            ^
// <console>:58: warning: implicit numeric widening
//        val list2 = (0 to 5).map(i => Order(i, i)).toList
//                                               ^
// list2: List[Order] = List(Order(0.0,0.0), Order(1.0,1.0), Order(2.0,2.0), Order(3.0,3.0), Order(4.0,4.0), Order(5.0,5.0))

val result1 = add(list1)
// result1: Option[Int] = Some(3)

val result2 = add(list2)
// result2: Order = Order(15.0,15.0)
```
---
###functor: a functor is anything with a map method
![:scale 90%](resources/map-type-chart.jpeg)
---
* We should think of map not as an iteration pattern, but as a way of sequencing computations on values ignoring some
complication dictated by the relevant data type

```scala
//package cats
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}
```
* F[_]: **type constructors and higher kinded types**
---
#### Functor Laws
* Identity: calling map with the identity function is the same as doing nothing:
```scala
fa.map(a => a) == fa
```
* Composition: mapping with two functions f and g is the same as
mapping with f and then mapping with g :
```scala
fa.map(g(f(_))) == fa.map(f).map(g)
```
* The trick is not to confuse type constructors with generic types. 

* List is a **type constructor**, 
List[A] is a **type**:

* There’s a close analogy here with functions and values. Functions are value constructors
```scala
math.abs // function, takes one parameter
math.abs(x) // value, produced by applying a value parameter
```
---
### lift:
* Functor provides a method called lift , which converts a function of 
**type A => B** to one that operates over a functor and has type **F[A] => F[B]** :

```scala
import cats.Functor
import cats.instances.all._
import cats.syntax.functor._
val func = (x: Int) => x + 1
// func: Int => Int = <function1>
val liftedFunc = Functor[Option].lift(func)
// liftedFunc: Option[Int] => Option[Int] = cats.Functor$$Lambda$7972/0x000000084250f840@195657fa58

liftedFunc(Option(1))
// res1: Option[Int] = Some(2)
```
---
### Functors represent sequencing behaviours. 
####We covered three types of functor in this chapter:
* Regular covariant Functors , with their map method, represent the abil‐
ity to apply functions to a value in some context. Successive calls to
map apply these functions in sequence, each accepting the result of its
predecessor as a parameter.
* Contravariant functors, with their contramap method, represent the
ability to “prepend” functions to a function‐like context. Successive
calls to contramap sequence these functions in the opposite order to
map .
* Invariant functors, with their imap method, represent bidirectional
transformations.
---
* contramap
![:scale 90%](resources/contramap-type-chart.jpeg)
* imap: equivalent to a combination of map and contramap
![:scale 90%](resources/imap-type-chart.jpeg)
---
* ex: Play JSON’s Format and scodec’s Codec .

```scala
trait Codec[A] {
  def encode(value: A): String
  def decode(value: String): A
  def imap[B](dec: A => B, enc: B => A): Codec[B] = ???
}
def encode[A](value: A)(implicit c: Codec[A]): String =
  c.encode(value)
def decode[A](value: String)(implicit c: Codec[A]): A =
  c.decode(value)

implicit val stringCodec: Codec[String] = new Codec[String] {
  def encode(value: String): String = value
  def decode(value: String): String = value
}
```
* to extend instances by imap

```scala
scala> import com.vpon.cat.Codec
import com.vpon.cat.Codec

scala> import com.vpon.cat.CodecInstances._
import com.vpon.cat.CodecInstances._

scala> implicit val intCodec: Codec[Int] = stringCodec.imap(_.toInt, _.toString)
intCodec: com.vpon.cat.Codec[Int] = com.vpon.cat.Codec$$anon$1@1be243d3

scala> implicit val booleanCodec: Codec[Boolean] = stringCodec.imap(_.toBoolean, _.toString)
booleanCodec: com.vpon.cat.Codec[Boolean] = com.vpon.cat.Codec$$anon$1@a09158b
```
---
* Contravariant and Invariant in Cats

```scala
trait Contravariant[F[_]] {
  def contramap[A, B](fa: F[A])(f: B => A): F[B]
}
trait Invariant[F[_]] {
  def imap[A, B](fa: F[A])(f: A => B)(g: B => A): F[B]
}
```
```scala
import cats.Contravariant
import cats.Show
import cats.instances.string._

val showString = Show[String]
val showSymbol = Contravariant[Show].

contramap(showString)((sym: Symbol) => s"'${sym.name}")
showSymbol.show(Symbol("dave"))
```
* use syntax:

```scala
import cats.syntax.contravariant._ // for contramap
showString.contramap[Symbol](sym => s"'${sym.name}").show(Symbol("dave"))
// res2: String = "'dave"
```
---
* imap on monoid to extend instance

```scala
import cats.Monoid
import cats.instances.string._ // for Monoid
import cats.syntax.invariant._ // for imap
import cats.syntax.semigroup._ // for |+|

implicit val symbolMonoid: Monoid[Symbol] =
Monoid[String].imap(Symbol.apply)(_.name)
Monoid[Symbol].empty
// res3: Symbol = '
Symbol("a") |+| Symbol("few") |+| Symbol("words")
// res4: Symbol = 'afewwords
```
---
* functor execise1

```scala
import cats.Functor
import cats.instances.all._
import cats.syntax.functor._

// trait Functor[F[_]] {
// def map[A, B](fa: F[A])(f: A => B): F[B]
// }

sealed trait Tree[+A]
final case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]
final case class Leaf[A](value: A) extends Tree[A]

implicit val treeFunctor: Functor[Tree] = new Functor[Tree] {
  def map[A, B](fa: Tree[A])(f: A => B): Tree[B] = {
    fa match {
      case Branch(left, right) => Branch(map(left)(f), map(right)(f))
      case Leaf(value) => Leaf(f(value))
    }
  }
}

object Tree {
  def branch[A](left: Tree[A], right: Tree[A]): Tree[A] =
    Branch(left, right)
  def leaf[A](value: A): Tree[A] =
    Leaf(value)
}
```
```scala
Tree.branch(Tree.leaf(10), Tree.leaf(20)).map(_ * 2)
// res5: Tree[Int] = Branch(Leaf(20),Leaf(40))
```
---
* partial unification need to add **YpartialUnification**(before scala2.13) in scalaOption

```scala
import cats.Functor
import cats.instances.function._ // for Functor
import cats.syntax.functor._ // for map
val func1 = (x: Int) => x.toDouble
val func2 = (y: Double) => y * 2

val func3 = func1.map(func2)
// func3: Int => Double = scala.Function1$$Lambda$7919/0x00000008424d3040@76a18834
```
* otherwise we’ll get a compiler error:

```scala
func1.map(func2)
// <console>: error: value map is not a member of Int => Double
//func1.map(func2)
```
---
###The partial unification in the Scala compiler works by fixing type parameters
from left to right. In the above example, the compiler fixes the Int in Int =>
Double and looks for a Functor for functions of type Int => ?

```scala
type F[A] = Int => A
val functor = Functor[F]
```
* compiler need to transform Function1 to Functor

```scala
trait Function1[-A, +B] {
  def apply(arg: A): B
}

trait Functor[F[_]] {
  def map[A, B](fa: F[A])(func: A => B): F[B]
}
```
---
#Monad
* a monad is anything with a constructor and a flatMap method
![:scale 90%](resources/flatMap-type-chart.jpeg)

* Monads are all about sequencing and fail fast 
* => how about if we don't want to fail fast and run parraral?(use .par)
---
###Monad operation
* pure , of type A => F[A] ;
* flatMap , of type (F[A], A => F[B]) => F[B] .

```scala
trait Monad[F[_]] {
  def pure[A](value: A): F[A]
  def flatMap[A, B](value: F[A])(func: A => F[B]): F[B]
}
```
### Monad Laws
* Left and right identity

```scala
pure(a).flatMap(func) == func(a)
m.flatMap(pure) == m
```
* Associativity

```scala
m.flatMap(f).flatMap(g) == m.flatMap(x => f(x).flatMap(g))
```
---
* Id monad is a good way for test

```scala
import cats.Monad
import cats.syntax.functor._ // for map
import cats.syntax.flatMap._ // for flatMap
import cats.instances.all._
import cats.Id
def sumSquare[F[_]: Monad](a: F[Int], b: F[Int]): F[Int] =
  for {
    x <- a 
    y <- b 
  } yield x*x + y*y 
```
```scala
sumSquare(Option(3), Option(4)) 
// res6: Option[Int] = Some(25)

sumSquare(List(1, 2, 3),List(4, 5)) 
// res7: List[Int] = List(17, 26, 20, 29, 25, 34)

sumSquare(3:Id[Int], 4:Id[Int]) 
// res8: cats.Id[Int] = 25
```
```scala
scala> sumSquare(3, 4) 
<console>:44: error: no type parameters for method sumSquare: (a: F[Int], b: F[Int])(implicit evidence$1: cats.Monad[F])F[Int] exist so that it can be applied to arguments (Int, Int)
 --- because ---
argument expression's type is not compatible with formal parameter type;
 found   : Int
 required: ?F[Int]
       sumSquare(3, 4)
       ^
<console>:44: error: type mismatch;
 found   : Int(3)
 required: F[Int]
       sumSquare(3, 4)
                 ^
<console>:44: error: type mismatch;
 found   : Int(4)
 required: F[Int]
       sumSquare(3, 4)
                    ^
```
---
* Either is monad after scala 2.12(right biased)

```scala
for {
  a <- either1
  b <- either2
} yield a + b
// res1: Either[String, Int] = Right(42)
```

* in scala 2.11,need to assign .right

```scala
for {
  a <- either1.right
  b <- either2.right
} yield a + b
```
---
* smart constructor for let Right and Left type can be **Either** type

```scala
import cats.syntax.either._ // for asRight
val a = 3.asRight[String]
// a: Either[String, Int] = Right(3)
val b = 4.asRight[String]
// b: Either[String, Int] = Right(4)

for {
  x <- a
  y <- b
} yield x*x + y*y
// res3: Either[String, Int] = Right(25)
```
* This helps avoid type inference problems
---
* issue example

```scala
scala> def countPositive(nums: List[Int]) =
     |   nums.foldLeft(Right(0)) { (accumulator, num) =>
     |     if(num > 0) {
     |       accumulator.map(_ + 1)
     |     } else {
     |       Left("Negative. Stopping!")
     |     }
     |   }
<console>:45: error: type mismatch;
 found   : scala.util.Either[Nothing,Int]
 required: scala.util.Right[Nothing,Int]
             accumulator.map(_ + 1)
                            ^
<console>:47: error: type mismatch;
 found   : scala.util.Left[String,Nothing]
 required: scala.util.Right[Nothing,Int]
             Left("Negative. Stopping!")
                 ^
```
* this compile fail due to
1. the compiler infers the type of the accumulator as **Right** instead of **Either** ;
2. we didn’t specify type parameters for Right.apply so the compiler infers the left parameter as **Nothing** .

---
* how to fix: use asRight to let 0 is Either type

```scala
import cats.syntax.either._ // for asRight

def countPositive(nums: List[Int]) =
  nums.foldLeft(0.asRight[String]) { (accumulator, num) =>
  if(num > 0) {
    accumulator.map(_ + 1)
  } else {
    Left("Negative. Stopping!")
  }
}
```
```scala
countPositive(List(1, 2, 3))
// res10: Either[String,Int] = Right(3)

countPositive(List(1, -2, 3))
// res11: Either[String,Int] = Left(Negative. Stopping!)
```
---
###transforming either:
* getOrElse, orElse
```scala
import cats.syntax.either._
"Error".asLeft[Int].getOrElse(0)
// res11: Int = 0
"Error".asLeft[Int].orElse(2.asRight[String])
// res12: Either[String, Int] = Right(2)
```
* ensure
```scala
-1.asRight[String].ensure("Must be non-negative!")(_ > 0)
// res13: Either[String, Int] = Left("Must be non-negative!")
```

* recover, recoverWith
```scala
"error".asLeft[Int].recover {
  case _: String => -1
}
// res14: Either[String, Int] = Right(-1)
"error".asLeft[Int].recoverWith {
  case _: String => Right(-1)
}
// res15: Either[String, Int] = Right(-1)
```
---
* leftMap, bimap
```scala
"foo".asLeft[Int].leftMap(_.reverse)
// res16: Either[String, Int] = Left("oof")
6.asRight[String].bimap(_.reverse, _ * 7)
// res17: Either[String, Int] = Right(42)
"bar".asLeft[Int].bimap(_.reverse, _ * 7)
// res18: Either[String, Int] = Left("rab")
```

* swap
```scala
123.asRight[String]
// res19: Either[String, Int] = Right(123)
123.asRight[String].swap
// res20: Either[Int, String] = Left(123)
```
---
* error handling by Either

```scala
object wrapper {
  sealed trait LoginError extends Product with Serializable
  final case class UserNotFound(username: String) extends LoginError
  final case class PasswordIncorrect(username: String) extends LoginError
  case object UnexpectedError extends LoginError
}
import wrapper._
case class User(username: String, password: String)
type LoginResult = Either[LoginError, User]

// Choose error-handling behaviour based on type:
def handleError(error: LoginError): Unit =
  error match {
    case UserNotFound(u) =>
      println(s"User not found: $u")
    case PasswordIncorrect(u) =>
      println(s"Password incorrect: $u")
    case UnexpectedError =>
      println(s"Unexpected error")
  }
```
```scala
val result1: LoginResult = User("dave", "passw0rd").asRight
// result1: LoginResult = Right(User(dave,passw0rd))

val result2: LoginResult = UserNotFound("dave").asLeft
// result2: LoginResult = Left(UserNotFound(dave))

result1.fold(handleError, println)
// User(dave,passw0rd)

result2.fold(handleError, println)
// User not found: dave
```
---
*  **Error recovery** is important when processing large jobs. We don’t want
to run a job for a day and then find it failed on the last element.
*  **Error reporting** is equally important. We need to know what went
wrong, not just that something went wrong.
*  In a number of cases, we want to collect all the errors, not just the first
one we encountered. A typical example is **validating a web form**. It’s a
far better experience to report all errors to the user when they submit
a form than to report them one at a time.
---
###MonadError
```scala
//package cats
trait MonadError[F[_], E] extends Monad[F] {
  // Lift an error into the `F` context:
  def raiseError[A](e: E): F[A]
  // Handle an error, potentially recovering from it:
  def handleErrorWith[A](fa: F[A])(f: E => F[A]): F[A]
  // Handle all errors, recovering from them:
  def handleError[A](fa: F[A])(f: E => A): F[A]
  // Test an instance of `F`,
  // failing if the predicate is not satisfied:
  def ensure[A](fa: F[A])(e: E)(f: A => Boolean): F[A]
}
```
---
* handleErrorWith via *cats.syntax.applicativError*
* ensure via *cats.syntax.monadError*

```scala
import cats.syntax.applicative._ // for pure
import cats.syntax.applicativeError._ // for raiseError etc
import cats.syntax.monadError._ // for ensure
// Alias Either to a type constructor with one parameter:
type ErrorOr[A] = Either[String, A]

val success = 42.pure[ErrorOr]
// success: ErrorOr[Int] = Right(42)
val failure = "Badness".raiseError[ErrorOr, Int]
// failure: ErrorOr[Int] = Left("Badness")
failure.handleErrorWith{
    case "Badness" => 256.pure[ErrorOr]
    case _ => ("It's not ok").raiseError[ErrorOr, Int]
}
// res4: ErrorOr[Int] = Right(256)
success.ensure("Number to low!")(_ > 1000)
// res5: ErrorOr[Int] = Left("Number to low!")
```
---
* monad execise1

```scala
import cats.MonadError
import cats.syntax.monadError._
import cats.syntax.applicativeError._
import cats.instances.all._
import scala.util.{Try, Success, Failure}

def validateAdult[F[_]](age: Int)(implicit me: MonadError[F, Throwable]): F[Int] = {
  age >= 18 match{
    case true => me.pure(age)
    case false => me.raiseError(throw new java.lang.IllegalArgumentException("Age must be greater than or equal to 18"))
  }
}
```
```scala
validateAdult[Try](18)
// res16: scala.util.Try[Int] = Success(18)

type ExceptionOr[A] = Either[Throwable, A]
// defined type alias ExceptionOr
```
```scala
scala> validateAdult[ExceptionOr](-1)
java.lang.IllegalArgumentException: Age must be greater than or equal to 18
  at .validateAdult(<console>:63)
  ... 42 elided
```
---
###Eval monad
#### eval monad with 3 types
* now: call‐by‐value which is eager and memoized;
* always: call‐by‐name which is lazy and not memoized; and
* later: call‐by‐need which is lazy and memoized.

```scala
import cats.Eval
// import cats.Eval

val now = Eval.now(math.random + 1000)
// now: cats.Eval[Double] = Now(1000.4964194285752)

val always = Eval.always(math.random + 3000)
// always: cats.Eval[Double] = cats.Always@6f1d7218

val later = Eval.later(math.random + 2000)
// later: cats.Eval[Double] = cats.Later@7e3c2ac2

now.value
// res18: Double = 1000.4964194285752

always.value
// res19: Double = 3000.903290017396

later.value
// res20: Double = 2000.218565809159
```
---
* mapping functions are always called lazily on demand ( **def semantics**):

```scala
import cats.Eval
// import cats.Eval

val ans = for {
  a <- Eval.now{ println("Calculating A"); 40 }
  b <- Eval.always{ println("Calculating B"); 2 }
} yield {
  println("Adding A and B")
  a + b
}
// Calculating A
// ans: cats.Eval[Int] = cats.Eval$$anon$4@6829c90d

ans.value // first access
// Calculating B
// Adding A and B
// res21: Int = 42

ans.value // second access
// Calculating B
// Adding A and B
// res22: Int = 42
```
---
* memorized method

```scala
import cats.Eval
// import cats.Eval

val saying = Eval.always{ println("Step 1"); "The cat" 
  }.map{ str => println("Step 2"); s"$str sat on" 
  }.memoize.map{ str => println("Step 3"); s"$str the mat" 
}
// saying: cats.Eval[String] = cats.Eval$$anon$4@13bfeb77

saying.value // first access
// Step 1
// Step 2
// Step 3
// res23: String = The cat sat on the mat

saying.value // second access
// Step 3
// res24: String = The cat sat on the mat
```

---
###stack safety of evals map and flatMap
* issue example: this would cause stack overflow

```scala
def factorial(n: BigInt): BigInt =
  if(n == 1) n else n * factorial(n - 1)
factorial(50000)
// java.lang.StackOverflowError
```
* use eavl to refactor….still stack overflow

```scala
def factorial(n: BigInt): Eval[BigInt] =
  if(n == 1) {
    Eval.now(n)
  } else {
    factorial(n - 1).map(_ * n)
  }
factorial(50000).value
// java.lang.StackOverflowError
```
---
* stack overflow reason
* still making all the recursive calls to factorial before we start working with Eval's map method.
* solution: use **eavl.defer** for the rescue!!

```scala
import cats.Eval
// import cats.Eval

def factorial(n: BigInt): Eval[BigInt] =
  if(n == 1) {
    Eval.now(n)
  } else {
    Eval.defer(factorial(n - 1).map(_ * n))
  }
// factorial: (n: BigInt)cats.Eval[BigInt]

factorial(50000).value
// res25: BigInt = 33473205095971448369154760940714864779127732238104548077301003219901680221443656416973812310719169308798480438190208299893616384743066693742630572845363784038325756282123359987268244078235972356040853854441373383753568565536371168327405166076155165921406156075461294201790567479665498629242220022541553510718159801615476451810616674970217996537474972541139338191638823500630307644256874857271394651081909874909643486268589229807870031031008962861154553979911612940652327396971497211031261142860733793509687837355811830609551728906603833592532851635961730885279811957399495299450306354442478492641028990069559634883529900557676550929175475920788044807622562415165130459046318068517406766360012329556454065724225175473428183121029195715593787423641117194513...
```
* cost of eavl: It avoids consuming stack by creating a chain of function objects on the heap. There are still limits on
how deeply we can nest computations, but they are bounded by the **size of the heap rather than the stack**.
---
###writer monad
* cats.data.Writer is a monad that lets us carry a log along with a computation

ex: recording sequences of steps in multithreaded computations where standard
 imperative logging techniques can result in interleaved messages from different contexts

* *cats.data* include writer, reader, state, monad transformers and validated

```scala
import cats.data.Writer
import cats.instances.vector._ // for Monoid
Writer(Vector(
"It was the best of times",
"it was the worst of times"
), 1859)
// res0: cats.data.WriterT[cats.package.Id, Vector[String], Int] = //WriterT((Vector("It was the best of times", "it was
//the worst of //times"),1859)
```

* writer is alias of writerT

```scala
type Writer[W, A] = WriterT[Id, W, A]
```
---
####writer syntax:
* user pure + monoid

```scala
import cats.instances.vector._ // for Monoid
import cats.syntax.applicative._ // for pure
type Logged[A] = Writer[Vector[String], A]
123.pure[Logged]
// res1: Logged[Int] = WriterT((Vector(), 123))
```

* use tell for create Writer[Unit]

```scala
import cats.syntax.writer._ // for tell
Vector("msg1", "msg2", "msg3").tell
// res2: Writer[Vector[String], Unit] = WriterT(
//(Vector("msg1", "msg2", "msg3"), ())
// )
```
---
* use run for get writer both result

```scala
import cats.syntax.writer._ // for writer
val a = Writer(Vector("msg1", "msg2", "msg3"), 123)
// a: cats.data.WriterT[cats.package.Id, Vector[String], Int] = WriterT(
//(Vector("msg1", "msg2", "msg3"), 123)
// )
val b = 123.writer(Vector("msg1", "msg2", "msg3"))
// b: Writer[Vector[String], Int] = WriterT(
//(Vector("msg1", "msg2", "msg3"), 123)
// )
val aResult: Int = a.value
// aResult: Int = 123
val aLog: Vector[String] = a.written
// aLog: Vector[String] = Vector("msg1", "msg2", "msg3")
val (log, result) = b.run
// log: Vector[String] = Vector("msg1", "msg2", "msg3")
// result: Int = 123
```
---
* concat log in writer

```scala
import cats.data.Writer
// import cats.data.Writer

import cats.instances.all._
// import cats.instances.all._

import cats.syntax.writer._
// import cats.syntax.writer._

import cats.syntax.applicative._
// import cats.syntax.applicative._

type Logged[A] = Writer[Vector[String], A]
// defined type alias Logged

val writer1 = for {
  a <- 10.pure[Logged] 
  _ <- Vector("a", "b" , "c" ).tell 
  b <- 32.writer(Vector("x", "y" , "z" )) 
} yield a + b // writer1:
// writer1: cats.data.WriterT[cats.Id,Vector[String],Int] = WriterT((Vector(a, b, c, x, y, z),42))

writer1.run
// res26: cats.Id[(Vector[String], Int)] = (Vector(a, b, c, x, y, z),42)
```
* use mapWritten to transform log in writer

```scala
val writer2 = writer1.mapWritten(_.map(_.toUpperCase))
// writer2: cats.data.WriterT[cats.Id,scala.collection.immutable.Vector[String],Int] = WriterT((Vector(A, B, C, X, Y, Z),42))
```
---
* transform log and value simutaneously by bimap and mapBoth

```scala
val writer3 = writer1.bimap(
  log => log.map(_.toUpperCase),
  res => res * 100
)
// writer3: cats.data.WriterT[cats.package.Id, Vector[String], Int] =
// WriterT(
// (Vector("A", "B", "C", "X", "Y", "Z"), 4200)
// )
writer3.run
// res5: (Vector[String], Int) = (Vector("A", "B", "C", "X", "Y", "Z"), 4200)
val writer4 = writer1.mapBoth { (log, res) =>
  val log2 = log.map(_ + "!")
  val res2 = res * 1000
(log2, res2)
}
// writer4: cats.data.WriterT[cats.package.Id, Vector[String], Int] =
// WriterT(
// (Vector("a!", "b!", "c!", "x!", "y!", "z!"), 42000)
// )
writer4.run
// res6: (Vector[String], Int) = (
// Vector("a!", "b!", "c!", "x!", "y!", "z!"),
// 42000
// )
```
---
* reset: reset log by reset function
* swap: swap log and value

```scala
val writer5 = writer1.reset
// writer5: cats.data.WriterT[cats.package.Id, Vector[String], Int] =
// WriterT(
//(Vector(), 42)
// )
writer5.run
// res7: (Vector[String], Int) = (Vector(), 42)
val writer6 = writer1.swap
// writer6: cats.data.WriterT[cats.package.Id, Int, Vector[String]] =
// WriterT(
// (42, Vector("a", "b", "c", "x", "y", "z"))
// )
writer6.run
// res8: (Int, Vector[String]) = (42, Vector("a", "b", "c", "x", "y",
// "z"))
```
---
###reader monad
* cats.data.Reader is a monad that allows us to sequence operations that depend on
 some input. ex: common use case is **dependency injection**

*  We can create a Reader[A, B] from a function A => B using the Reader.apply constructor:

```scala
import cats.data.Reader
final case class Cat(name: String, favoriteFood: String)
```
```scala
val catName: Reader[Cat, String] = Reader(cat => cat.name)
// catName: cats.data.Reader[Cat,String] = Kleisli($$Lambda$55343/712489089@57888228)

  catName.run(Cat("Garfield", "lasagne"))
// res27: cats.Id[String] = Garfield
```
---
* The power of Readers comes from their map and flatMap methods to make **sequencing operation**

```scala
val feedKitty: Reader[Cat, String] =
Reader(cat => s"Have a nice bowl of ${cat.favoriteFood}")
val greetAndFeed: Reader[Cat, String] =
for {
  greet <- greetKitty 
  feed <- feedKitty 
} yield s"$greet. $feed." 

greetAndFeed(Cat("Garfield", "lasagne" )) // res3:
cats.package.Id[String]="Hello Garfield. Have a nice bowl of // lasagne." 
greetAndFeed(Cat("Heathcliff", "junk food")) 
// res4: cats.package.Id[String]="Hello Heathcliff. Have a nice bowl
// of junk food."
```
---
* reader monad execise 1

```scala
import cats.data.Reader
import cats.Eq
import cats.instances.all._
import cats.syntax.eq._ //for eq

final case class Db(
    usernames: Map[Int, String],
    passwords: Map[String, String]
)

type DbReader[A] = Reader[Db, A]

def findUsername(userId: Int): DbReader[Option[String]] = {
    Reader(db => db.usernames.get(userId))
}

def checkPassword(usernameOpt: Option[String], password: String): DbReader[Boolean] = {
    Reader(db => usernameOpt.map(username => db.passwords.get(username).exists(i => i === password))
    .getOrElse(false)
    )
}

def checkLogin(userId: Int, password: String): DbReader[Boolean] = {
    for {
        nameOpt <- findUsername(userId)
        isValid <- checkPassword(nameOpt, password)
    } yield {
        isValid
    }
}
```
---
* reader monad execise 1(cont.)

```scala
val users = Map(
    1 -> "dade",
    2 -> "kate",
    3 -> "margo"
)
// users: scala.collection.immutable.Map[Int,String] = Map(1 -> dade, 2 -> kate, 3 -> margo)

val passwords = Map(
  "dade" -> "zerocool",
  "kate" -> "acidburn",
  "margo" -> "secret"
)
// passwords: scala.collection.immutable.Map[String,String] = Map(dade -> zerocool, kate -> acidburn, margo -> secret)

val db = Db(users, passwords)
// db: Db = Db(Map(1 -> dade, 2 -> kate, 3 -> margo),Map(dade -> zerocool, kate -> acidburn, margo -> secret))

checkLogin(1, "zerocool").run(db)
// res28: cats.Id[Boolean] = true

checkLogin(4, "davinci").run(db)
// res29: cats.Id[Boolean] = false
```
---
#### when to use Reader?
* how many ways to do dependency injection?
  1. methods with multiple parameter lists
  2. implicit parameters and type classes
  3. cake pattern and DI frameworks(google guice)

* Readers are most useful in situations where:
  1. we are constructing a program that can easily be represented by a function;
  2. we need to defer injection of a known parameter or set of parameters;
  3. we want to be able to test parts of the program in isolation.
---
###State Monad
* *cats.data.State* allows us to pass additional state around as part of a computation.
type **S => (S, A)** . S is the type of the state and A is the type of the result.

```scala
import cats.data.State
// import cats.data.State

val a = State[Int, String]{ state =>
  (state, s"The state is $state")
}
// a: cats.data.State[Int,String] = cats.data.IndexedStateT@251017f0
```
* transforms an input state to an output state;
* computes a result.
---
* run, runS, runA

```scala
// Get the state and the result:
val (state, result) = a.run(10).value
// state: Int = 10
// result: String = "The state is 10"
// Get the state, ignore the result:
val justTheState = a.runS(10).value
// justTheState: Int = 10
// Get the result, ignore the state:
val justTheResult = a.runA(10).value
// justTheResult: String = "The state is 10"
```
---
* compose and transform state monad

```scala
val step1 = State[Int, String]{ num =>
val ans = num + 1
(ans, s"Result of step1: $ans")
}
val step2 = State[Int, String]{ num =>
val ans = num * 2
(ans, s"Result of step2: $ans")
}
val both = for {
  a <- step1 
  b <- step2 
} yield (a, b) 
val (state, result)=both.run(20).value 
// state: Int=42 
// result: (String,  String)=("Result of step1: 21", "Result of step2: 42" )
```
---
* Cats provides several convenience constructors for creating primitive steps:
  * get extracts the state as the result;
  * set updates the state and returns unit as the result;
  * pure ignores the state and returns a supplied result;
  * inspect extracts the state via a transformation function;
  * modify updates the state using an update function.
```scala
val getDemo = State.get[Int]
// getDemo: State[Int, Int] = cats.data.IndexedStateT@796af713
getDemo.run(10).value
// res1: (Int, Int) = (10, 10)
val setDemo = State.set[Int](30)
// setDemo: State[Int, Unit] = cats.data.IndexedStateT@f9e66fa
setDemo.run(10).value
// res2: (Int, Unit) = (30, ())
val pureDemo = State.pure[Int, String]("Result")
// pureDemo: State[Int, String] = cats.data.IndexedStateT@439e3ee4
pureDemo.run(10).value
// res3: (Int, String) = (10, "Result")
val inspectDemo = State.inspect[Int, String](x => s"${x}!")
// inspectDemo: State[Int, String] = cats.data.IndexedStateT@77263be4
inspectDemo.run(10).value
// res4: (Int, String) = (10, "10!")
val modifyDemo = State.modify[Int](_ + 1)
// modifyDemo: State[Int, Unit] = cats.data.IndexedStateT@44ddcbfc
modifyDemo.run(10).value
// res5: (Int, Unit) = (11, ())
```
---
```scala
import cats.data.State
// import cats.data.State

import State._
// import State._

val program: State[Int, (Int, Int, Int)] = for {
  a <- get[Int] 
  _ <- set[Int](a + 1) 
  b <- get[Int] 
  _ <- modify[Int](_ + 1) 
  c <- inspect[Int, Int](_ * 1000) 
} yield (a, b, c) 
// program: cats.data.State[Int,(Int, Int, Int)] = cats.data.IndexedStateT@21b5e84c

val (state, result)=program.run(1).value 
// state: Int = 3
// result: (Int, Int, Int) = (1,2,3000)
```
---
* defining custom monad
* implement: pure, flatMap, tailRecM
  * ex: Option:

```scala
import cats.Monad
import scala.annotation.tailrec
val optionMonad = new Monad[Option] {
  def flatMap[A, B](opt: Option[A])(fn: A => Option[B]): Option[B] =
    opt flatMap fn
  
  def pure[A](opt: A): Option[A] =
    Some(opt)
  
  @tailrec
  def tailRecM[A, B](a: A)(fn: A => Option[Either[A, B]]): Option[B] =
    fn(a) match {
      case None => None
      case Some(Left(a1)) => tailRecM(a1)(fn)
      case Some(Right(b)) => Some(b)
    }
  }
}
```
---
* flatMap syntax is not stack safe

```scala
import cats.syntax.flatMap._ // For flatMap
def retry[F[_]: Monad, A](start: A)(f: A => F[A]): F[A] =
  f(start).flatMap{ a =>
    retry(a)(f)
  }
```
```scala
retry(100000)(a => if(a == 0) None else Some(a - 1))
//get StackOverflowError .
```

* use tail recursion to fix it

```scala
import cats.syntax.functor._ // for map
def retryTailRecM[F[_]: Monad, A](start: A)(f: A => F[A]): F[A] =
Monad[F].tailRecM(start){ a =>
f(a).map(a2 => Left(a2))
}

retryTailRecM(100000)(a => if(a == 0) None else Some(a - 1))
// res2: Option[Int] = None
```
---
* some convinent util: iterateWhileM

```scala
import cats.syntax.monad._ // for iterateWhileM
// import cats.syntax.monad._

def retryM[F[_]: Monad, A](start: A)(f: A => F[A]): F[A] =
  start.iterateWhileM(f)(a => true)
// retryM: [F[_], A](start: A)(f: A => F[A])(implicit evidence$1: cats.Monad[F])F[A]

retryM(100000)(a => if(a == 0) None else Some(a - 1))
// res30: Option[Int] = None
```
* monad for sequencing operation, ex:
  * Option represents a computation that can fail without an error message,
  * Either represents computations that can fail with a message,
  * List represents multiple possible results, and
  * Future represents a computation that may produce a value at some point in the future.
  * some custom: Id , Reader , Writer , and State

---
###monad transformers
* Cats defines transformers for a variety of monads, 
* each providing the extra knowledge we need to compose that monad with others.
* The type signatures of monad transformers are written **from the inside out**, 
so an **EitherT[Option, String, A]** is a wrapper for an **Option[Either[String, A]]**

ex: EitherT composes Either with other monads, OptionT composes Option
```scala
import cats.data.OptionT
type ListOption[A] = OptionT[List, A]

import cats.instances.list._
// for Monad
import cats.syntax.applicative._ // for pure
val result1: ListOption[Int] = OptionT(List(Option(10)))
// result1: ListOption[Int] = OptionT(List(Some(10)))
val result2: ListOption[Int] = 32.pure[ListOption]
// result2: ListOption[Int] = OptionT(List(Some(32)))
result1.flatMap { (x: Int) =>
  result2.map { (y: Int) =>
    x + y
  }
}
// res1: OptionT[List, Int] = OptionT(List(Some(42)))
```
---
* The combined map and flatMap methods allow us to use both component monads 
without having to recursively unpack and repack values at each stage in the computation.


---
###Reference
* [scala with cats2](https://www.scalawithcats.com/ "www.scalawithcats.com")
* [cats FAQ](https://typelevel.org/cats/faq.html)
* [Useful Ammonite snippets](https://gist.github.com/MateuszKubuszok/a80503b28f289f08f2f6c6c70871e8d3#partial-unification)
* [9-tips-about-using-cats-in-scala-you-might-want-to-know](https://blog.softwaremill.com/9-tips-about-using-cats-in-scala-you-might-want-to-know-e1bafd365f88)
* [monad-transformers-for-the-working-programmer](https://blog.buildo.io/monad-transformers-for-the-working-programmer-aa7e981190e7)
* [flinters engineers blog](https://labs.septeni.co.jp/entry/functional-brothers)
* [Monad Transformers for the working programmer | by Gabriele Petronella](https://speakerdeck.com/danielasfregola/scalamatsuri-2018-a-pragmatic-introduction-to-category-theory)
* [DanielaSfregola github](https://github.com/DanielaSfregola)

---
class: center, middle

# Thanks!
Code and slides at `chenghsienwen/scalacatexecise` on GitHub

## Questions?





 </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
       remark.macros.scale = function (percentage) {
          var url = this;
          return '<img src="' + url + '" style="width: ' + percentage + '" />';
        };
        var slideshow = remark.create();
    </script>
  </body>
</html>
